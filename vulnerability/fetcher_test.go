// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package vulnerability

import (
	"context"
	"errors"
	"sync"
	"testing"
	"time"

	"github.com/aws/aws-sdk-go-v2/service/ec2/types"
	"github.com/aws/aws-sdk-go/aws"
	"github.com/samber/lo"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/suite"
	"go.uber.org/goleak"

	"github.com/elastic/cloudbeat/resources/providers/awslib/ec2"
	"github.com/elastic/cloudbeat/resources/utils/testhelper"
)

var (
	instanceId1             = "instance-1"
	instanceId1RootDevice   = "root-device-1"
	instanceId1RootVolumeId = "volume-1"
	instanceId2             = "instance-2"
	instanceId2RootDevice   = "root-device-2"
	instanceId2RootVolumeId = "volume-2"
	instanceId3             = "instance-3"
	instanceId3RootDevice   = "root-device-3"
	instanceId3RootVolumeId = "volume-3"
)

func generateInstance(id string, rootDevice string) *ec2.Ec2Instance {
	return &ec2.Ec2Instance{
		Instance: types.Instance{InstanceId: aws.String(id), RootDeviceName: aws.String(rootDevice)},
	}
}

func gernerateVolume(instanceId string, id string, device string, size int) *ec2.Volume {
	return &ec2.Volume{
		VolumeId:   id,
		InstanceId: instanceId,
		Device:     device,
		Size:       size,
	}
}

func generateTestInstances() (*ec2.Ec2Instance, *ec2.Ec2Instance, *ec2.Ec2Instance) {
	return generateInstance(instanceId1, instanceId1RootDevice),
		generateInstance(instanceId2, instanceId2RootDevice),
		generateInstance(instanceId3, instanceId3RootDevice)
}

func generateTestVolumes() (*ec2.Volume, *ec2.Volume, *ec2.Volume, *ec2.Volume, *ec2.Volume, *ec2.Volume) {
	return gernerateVolume(instanceId1, "some-vol-id-1", "some-device-1", 1),
		gernerateVolume(instanceId1, instanceId1RootVolumeId, instanceId1RootDevice, 10),
		gernerateVolume(instanceId2, instanceId2RootVolumeId, instanceId2RootDevice, 20),
		gernerateVolume(instanceId3, "some-vol-id-3", "some-device-3", 30),
		gernerateVolume(instanceId3, instanceId3RootVolumeId, instanceId3RootDevice, 5),
		gernerateVolume(instanceId3, "some-vol-id-3", "some-device-3", 50)
}

type FetcherTestSuite struct {
	suite.Suite
	opts goleak.Option
}

func TestFetcherTestSuite(t *testing.T) {
	testhelper.SkipLong(t)

	s := new(FetcherTestSuite)
	s.opts = goleak.IgnoreCurrent()
	suite.Run(t, s)
}

func (s *FetcherTestSuite) TearDownTest() {
	goleak.VerifyNone(s.T(), s.opts)
}

func (s *FetcherTestSuite) TestVulnerabilityFetcher_FetchInstances() {
	instance1, instance2, instance3 := generateTestInstances()
	volume11, volume12, volume2, volumes31, volumes32, volumes33 := generateTestVolumes()
	m := newMockInstancesProvider(s.T())
	m.EXPECT().DescribeInstances(mock.Anything).Return([]*ec2.Ec2Instance{instance1, instance2, instance3}, nil)
	m.EXPECT().DescribeVolumes(mock.Anything, mock.Anything).Return([]*ec2.Volume{volume11, volume12, volume2, volumes31, volumes32, volumes33}, nil)

	fetcher := NewVulnerabilityFetcher(testhelper.NewLogger(s.T()), m)

	ctx := context.TODO()

	wg := sync.WaitGroup{}
	// Test successful fetch
	wg.Add(1)
	go func() {
		defer wg.Done()
		err := fetcher.FetchInstances(ctx)
		s.Require().NoError(err)
	}()

	ch := fetcher.GetChan()
	s.Assertions.NotNil(ch)

	receivedInstances := []*ec2.Ec2Instance{}
	for in := range ch {
		receivedInstances = append(receivedInstances, in)
	}
	_, ok := <-ch
	s.Assertions.False(ok)

	s.Assertions.Equal([]*ec2.Ec2Instance{instance3, instance1, instance2}, receivedInstances)

	volumes := lo.Map(receivedInstances, func(in *ec2.Ec2Instance, _ int) int {
		return in.RootVolume.Size
	})
	s.Assertions.IsIncreasing(volumes, receivedInstances)
	wg.Wait()
}

func (s *FetcherTestSuite) TestVulnerabilityFetcher_FetchInstances_MissingVolumes() {
	instance1, instance2, instance3 := generateTestInstances()
	_, _, volume2, volumes31, volumes32, volumes33 := generateTestVolumes()
	m := newMockInstancesProvider(s.T())
	m.EXPECT().DescribeInstances(mock.Anything).Return([]*ec2.Ec2Instance{instance1, instance2, instance3}, nil)
	m.EXPECT().DescribeVolumes(mock.Anything, mock.Anything).Return([]*ec2.Volume{volume2, volumes31, volumes32, volumes33}, nil)

	fetcher := NewVulnerabilityFetcher(testhelper.NewLogger(s.T()), m)

	ctx := context.TODO()

	wg := sync.WaitGroup{}
	// Test successful fetch
	wg.Add(1)
	go func() {
		defer wg.Done()
		err := fetcher.FetchInstances(ctx)
		s.Require().NoError(err)
	}()

	ch := fetcher.GetChan()
	s.Assertions.NotNil(ch)

	receivedInstances := []*ec2.Ec2Instance{}
	for in := range ch {
		receivedInstances = append(receivedInstances, in)
	}
	_, ok := <-ch
	s.Assertions.False(ok)

	s.Assertions.Equal([]*ec2.Ec2Instance{instance3, instance2, instance1}, receivedInstances)

	wg.Wait()
}

func (s *FetcherTestSuite) TestVulnerabilityFetcher_FetchInstances_DescribeVolumeError() {
	instance1, instance2, instance3 := generateTestInstances()
	m := newMockInstancesProvider(s.T())
	m.EXPECT().DescribeInstances(mock.Anything).Return([]*ec2.Ec2Instance{instance1, instance2, instance3}, nil)
	m.EXPECT().DescribeVolumes(mock.Anything, mock.Anything).Return(nil, errors.New("some error"))

	fetcher := NewVulnerabilityFetcher(testhelper.NewLogger(s.T()), m)

	ctx := context.TODO()

	wg := sync.WaitGroup{}
	// Test successful fetch
	wg.Add(1)
	go func() {
		defer wg.Done()
		err := fetcher.FetchInstances(ctx)
		s.Require().NoError(err)
	}()

	ch := fetcher.GetChan()
	s.Assertions.NotNil(ch)

	receivedInstances := []*ec2.Ec2Instance{}
	for in := range ch {
		receivedInstances = append(receivedInstances, in)
	}
	_, ok := <-ch
	s.Assertions.False(ok)

	s.Assertions.Equal([]*ec2.Ec2Instance{instance1, instance2, instance3}, receivedInstances)

	wg.Wait()
}

func (s *FetcherTestSuite) TestVulnerabilityFetcher_FetchInstances_DescribeInstancesError() {
	m := newMockInstancesProvider(s.T())
	m.EXPECT().DescribeInstances(mock.Anything).Return(nil, errors.New("some error"))

	fetcher := NewVulnerabilityFetcher(testhelper.NewLogger(s.T()), m)

	ctx := context.TODO()

	err := fetcher.FetchInstances(ctx)
	s.Require().Error(err)

	ch := fetcher.GetChan()
	s.Require().NotNil(ch)

	_, ok := <-ch
	s.Assertions.False(ok)
}

func (s *FetcherTestSuite) TestVulnerabilityFetcher_FetchInstances_Cancel() {
	instance1, instance2, instance3 := generateTestInstances()
	volume11, volume12, volume2, volumes31, volumes32, volumes33 := generateTestVolumes()
	m := newMockInstancesProvider(s.T())
	m.EXPECT().DescribeInstances(mock.Anything).Return([]*ec2.Ec2Instance{instance1, instance2, instance3}, nil)
	m.EXPECT().DescribeVolumes(mock.Anything, mock.Anything).Return([]*ec2.Volume{volume11, volume12, volume2, volumes31, volumes32, volumes33}, nil)

	fetcher := NewVulnerabilityFetcher(testhelper.NewLogger(s.T()), m)

	ctx, cancel := context.WithCancel(context.Background())
	cancel() // Cancel the context immediately

	err := fetcher.FetchInstances(ctx)
	s.Require().NoError(err)

	ch := fetcher.GetChan()
	s.Require().NotNil(ch)

	_, ok := <-ch
	s.Assertions.False(ok)
}

func (s *FetcherTestSuite) TestVulnerabilityFetcher_FetchInstances_DelayCancel() {
	instance1, instance2, instance3 := generateTestInstances()
	volume11, volume12, volume2, volumes31, volumes32, volumes33 := generateTestVolumes()
	m := newMockInstancesProvider(s.T())
	m.EXPECT().DescribeInstances(mock.Anything).Return([]*ec2.Ec2Instance{instance1, instance2, instance3}, nil)
	m.EXPECT().DescribeVolumes(mock.Anything, mock.Anything).Return([]*ec2.Volume{volume11, volume12, volume2, volumes31, volumes32, volumes33}, nil)

	fetcher := NewVulnerabilityFetcher(testhelper.NewLogger(s.T()), m)

	ctx, cancel := context.WithCancel(context.Background())
	go func() {
		<-time.After(100 * time.Millisecond)
		cancel() // Cancel the context after 100ms
	}()

	err := fetcher.FetchInstances(ctx)
	s.Require().NoError(err)

	ch := fetcher.GetChan()
	s.Require().NotNil(ch)

	_, ok := <-ch
	s.Assertions.False(ok)
}
