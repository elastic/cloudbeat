// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package vulnerability

import (
	"context"
	"errors"
	"sync"
	"testing"
	"time"

	"github.com/aws/aws-sdk-go-v2/service/ec2/types"
	"github.com/aws/aws-sdk-go/aws"
	"github.com/samber/lo"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/suite"
	"go.uber.org/goleak"

	"github.com/elastic/cloudbeat/resources/providers/awslib/ec2"
	"github.com/elastic/cloudbeat/resources/utils/testhelper"
)

var (
	instanceId1             = "instance-1"
	instanceId1RootDevice   = "root-device-1"
	instanceId1RootVolumeId = "volume-1"
	instanceId2             = "instance-2"
	instanceId2RootDevice   = "root-device-2"
	instanceId2RootVolumeId = "volume-2"
	instanceId3             = "instance-3"
	instanceId3RootDevice   = "root-device-3"
	instanceId3RootVolumeId = "volume-3"
)

var instance1 = &ec2.Ec2Instance{
	Instance: types.Instance{InstanceId: aws.String(instanceId1), RootDeviceName: aws.String(instanceId1RootDevice)},
}

var volume11 = &ec2.Volume{
	InstanceId: instanceId1,
	VolumeId:   "some-vol-id-1",
	Device:     "some-device-1",
	Size:       1,
}
var volume12 = &ec2.Volume{
	InstanceId: instanceId1,
	VolumeId:   instanceId1RootVolumeId,
	Device:     instanceId1RootDevice,
	Size:       10,
}

var instance2 = &ec2.Ec2Instance{
	Instance: types.Instance{InstanceId: aws.String(instanceId2), RootDeviceName: aws.String(instanceId2RootDevice)},
}
var volume2 = &ec2.Volume{
	InstanceId: instanceId2,
	VolumeId:   instanceId2RootVolumeId,
	Device:     instanceId2RootDevice,
	Size:       20,
}

var instance3 = &ec2.Ec2Instance{
	Instance: types.Instance{InstanceId: aws.String(instanceId3), RootDeviceName: aws.String(instanceId3RootDevice)},
}

var volumes31 = &ec2.Volume{
	InstanceId: instanceId3,
	VolumeId:   "some-vol-id-3",
	Device:     "some-device-3",
	Size:       30,
}
var volumes32 = &ec2.Volume{
	InstanceId: instanceId3,
	VolumeId:   instanceId3RootVolumeId,
	Device:     instanceId3RootDevice,
	Size:       5,
}
var volumes33 = &ec2.Volume{
	InstanceId: instanceId3,
	VolumeId:   "other-vol-id-3",
	Device:     "other-device-3",
	Size:       50,
}

type FetcherTestSuite struct {
	suite.Suite
	opts goleak.Option
}

func TestFetcherTestSuite(t *testing.T) {
	s := new(FetcherTestSuite)
	s.opts = goleak.IgnoreCurrent()
	suite.Run(t, s)
}

func (s *FetcherTestSuite) TearDownTest() {
	goleak.VerifyNone(s.T(), s.opts)
}

func (s *FetcherTestSuite) TestVulnerabilityFetcher_FetchInstances() {
	m := &mockInstancesProvider{}
	m.EXPECT().DescribeInstances(mock.Anything).Return([]*ec2.Ec2Instance{instance1, instance2, instance3}, nil)
	m.EXPECT().DescribeVolumes(mock.Anything, mock.Anything).Return([]*ec2.Volume{volume11, volume12, volume2, volumes31, volumes32, volumes33}, nil)
	defer m.AssertExpectations(s.T())

	fetcher := NewVulnerabilityFetcher(testhelper.NewLogger(s.T()), m)

	ctx := context.TODO()

	wg := sync.WaitGroup{}
	// Test successful fetch
	wg.Add(1)
	go func() {
		defer wg.Done()
		err := fetcher.FetchInstances(ctx)
		s.Assertions.NoError(err)
	}()

	ch := fetcher.GetChan()
	s.Assertions.NotNil(ch)

	receivedInstances := []*ec2.Ec2Instance{}
	for in := range ch {
		receivedInstances = append(receivedInstances, in)
	}
	_, ok := <-ch
	s.Assertions.False(ok)

	s.Assertions.Equal(receivedInstances, []*ec2.Ec2Instance{instance3, instance1, instance2})

	volumes := lo.Map(receivedInstances, func(in *ec2.Ec2Instance, _ int) int {
		return in.RootVolume.Size
	})
	s.Assertions.IsIncreasing(volumes, receivedInstances)
	wg.Wait()
}

func (s *FetcherTestSuite) TestVulnerabilityFetcher_FetchInstances_MissingVolumes() {
	m := &mockInstancesProvider{}
	m.EXPECT().DescribeInstances(mock.Anything).Return([]*ec2.Ec2Instance{instance1, instance2, instance3}, nil)
	m.EXPECT().DescribeVolumes(mock.Anything, mock.Anything).Return([]*ec2.Volume{volume2, volumes31, volumes32, volumes33}, nil)
	defer m.AssertExpectations(s.T())

	fetcher := NewVulnerabilityFetcher(testhelper.NewLogger(s.T()), m)

	ctx := context.TODO()

	wg := sync.WaitGroup{}
	// Test successful fetch
	wg.Add(1)
	go func() {
		defer wg.Done()
		err := fetcher.FetchInstances(ctx)
		s.Assertions.NoError(err)
	}()

	ch := fetcher.GetChan()
	s.Assertions.NotNil(ch)

	receivedInstances := []*ec2.Ec2Instance{}
	for in := range ch {
		receivedInstances = append(receivedInstances, in)
	}
	_, ok := <-ch
	s.Assertions.False(ok)

	s.Assertions.Equal(receivedInstances, []*ec2.Ec2Instance{instance3, instance2, instance1})

	wg.Wait()
}

func (s *FetcherTestSuite) TestVulnerabilityFetcher_FetchInstances_DescribeVolumeError() {
	m := &mockInstancesProvider{}
	m.EXPECT().DescribeInstances(mock.Anything).Return([]*ec2.Ec2Instance{instance1, instance2, instance3}, nil)
	m.EXPECT().DescribeVolumes(mock.Anything, mock.Anything).Return(nil, errors.New("some error"))
	defer m.AssertExpectations(s.T())

	fetcher := NewVulnerabilityFetcher(testhelper.NewLogger(s.T()), m)

	ctx := context.TODO()

	wg := sync.WaitGroup{}
	// Test successful fetch
	wg.Add(1)
	go func() {
		defer wg.Done()
		err := fetcher.FetchInstances(ctx)
		s.Assertions.NoError(err)
	}()

	ch := fetcher.GetChan()
	s.Assertions.NotNil(ch)

	receivedInstances := []*ec2.Ec2Instance{}
	for in := range ch {
		receivedInstances = append(receivedInstances, in)
	}
	_, ok := <-ch
	s.Assertions.False(ok)

	s.Assertions.Equal(receivedInstances, []*ec2.Ec2Instance{instance1, instance2, instance3})

	wg.Wait()
}

func (s *FetcherTestSuite) TestVulnerabilityFetcher_FetchInstances_DescribeInstancesError() {
	m := &mockInstancesProvider{}
	m.EXPECT().DescribeInstances(mock.Anything).Return(nil, errors.New("some error"))
	defer m.AssertExpectations(s.T())

	fetcher := NewVulnerabilityFetcher(testhelper.NewLogger(s.T()), m)

	ctx := context.TODO()

	err := fetcher.FetchInstances(ctx)
	s.Assertions.Error(err)

	ch := fetcher.GetChan()
	s.Assertions.NotNil(ch)

	_, ok := <-ch
	s.Assertions.False(ok)
}

func (s *FetcherTestSuite) TestVulnerabilityFetcher_FetchInstances_Cancel() {
	m := &mockInstancesProvider{}
	m.EXPECT().DescribeInstances(mock.Anything).Return([]*ec2.Ec2Instance{instance1, instance2, instance3}, nil)
	m.EXPECT().DescribeVolumes(mock.Anything, mock.Anything).Return([]*ec2.Volume{volume11, volume12, volume2, volumes31, volumes32, volumes33}, nil)
	defer m.AssertExpectations(s.T())

	fetcher := NewVulnerabilityFetcher(testhelper.NewLogger(s.T()), m)

	ctx, cancel := context.WithCancel(context.Background())
	cancel() // Cancel the context immediately

	err := fetcher.FetchInstances(ctx)
	s.Assertions.NoError(err)

	ch := fetcher.GetChan()
	s.Assertions.NotNil(ch)

	_, ok := <-ch
	s.Assertions.False(ok)
}

func (s *FetcherTestSuite) TestVulnerabilityFetcher_FetchInstances_DelayCancel() {
	m := &mockInstancesProvider{}
	m.EXPECT().DescribeInstances(mock.Anything).Return([]*ec2.Ec2Instance{instance1, instance2, instance3}, nil)
	m.EXPECT().DescribeVolumes(mock.Anything, mock.Anything).Return([]*ec2.Volume{volume11, volume12, volume2, volumes31, volumes32, volumes33}, nil)
	defer m.AssertExpectations(s.T())

	fetcher := NewVulnerabilityFetcher(testhelper.NewLogger(s.T()), m)

	ctx, cancel := context.WithCancel(context.Background())
	go func() {
		<-time.After(100 * time.Millisecond)
		cancel() // Cancel the context after 100ms
	}()

	err := fetcher.FetchInstances(ctx)
	s.Assertions.NoError(err)

	ch := fetcher.GetChan()
	s.Assertions.NotNil(ch)

	_, ok := <-ch
	s.Assertions.False(ok)
}
