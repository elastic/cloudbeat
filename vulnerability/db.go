// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package vulnerability

import (
	"context"
	"fmt"
	"os"
	"time"

	"github.com/aquasecurity/trivy-db/pkg/metadata"
	"github.com/elastic/elastic-agent-libs/logp"

	"github.com/aquasecurity/trivy/pkg/commands/artifact"
	"github.com/aquasecurity/trivy/pkg/flag"
	trivy_types "github.com/aquasecurity/trivy/pkg/types"
)

type VulnerabilityDBManager struct {
	log *logp.Logger
}

const (
	// rekorUrl is the default URL for rekor
	rekorUrl     = "https://rekor.sigstore.dev"
	dbRepository = "ghcr.io/aquasecurity/trivy-db"
	cacheDir     = "/tmp/trivy-cache"
	tmpCacheDir  = "/tmp/trivy-cache-tmp"
)

func NewVulnerabilityDBManager(log *logp.Logger) VulnerabilityDBManager {
	log.Debug("NewVulnerabilityDBManager: New")

	return VulnerabilityDBManager{
		log: log,
	}
}

func (f VulnerabilityDBManager) Download(ctx context.Context) (string, error) {
	// Trivy configuration for downloading vulnerabilities DB and storing it in cache
	// The configuration will download both OS and language specific vulnerabilities
	// After the DB is downloaded, no scan will be performed
	opts := flag.Options{
		GlobalOptions: flag.GlobalOptions{
			Timeout:  1 * time.Hour,
			Quiet:    false,
			Debug:    true,
			CacheDir: tmpCacheDir,
		},
		VulnerabilityOptions: flag.VulnerabilityOptions{
			VulnType:      []string{trivy_types.VulnTypeOS, trivy_types.VulnTypeLibrary},
			IgnoreUnfixed: false, // display vulnerabilities even if they don't have a fix available
		},
		ScanOptions: flag.ScanOptions{
			Scanners: []trivy_types.Scanner{trivy_types.VulnerabilityScanner},
			RekorURL: rekorUrl,
		},
		DBOptions: flag.DBOptions{
			NoProgress:     true, // Don't print download progress bar
			DBRepository:   dbRepository,
			DownloadDBOnly: true,
		},
	}
	err := artifact.Run(ctx, opts, artifact.TargetVM)
	if err != nil {
		f.log.Errorf("VulnerabilityDBManager: checking cache after init error: %v", err)
		err := f.useCache()
		if err != nil {
			return "", fmt.Errorf("VulnerabilityDBManager: could not use cached DB: %w", err)
		}
	} else {
		err = f.setCache()
		if err != nil {
			f.log.Errorf("VulnerabilityDBManager: could not set DB in cache: %v", err)
			return tmpCacheDir, nil
		}
	}

	return cacheDir, nil
}

func (f VulnerabilityDBManager) useCache() error {
	client := metadata.NewClient(cacheDir)
	cache, err := client.Get()
	if err != nil {
		return fmt.Errorf("VulnerabilityDBManager: could not find cache: %w", err)
	}

	// TODO: Change cloudbeat status to unhealthy
	t1 := time.Now()
	diff := t1.Sub(cache.DownloadedAt)
	f.log.Info("VulnerabilityDBManager: using cache from: ", diff)
	return nil
}

func (f VulnerabilityDBManager) setCache() error {
	var err error
	err = os.RemoveAll(cacheDir)
	if err != nil {
		return err
	}
	err = os.Rename(tmpCacheDir, cacheDir)
	if err != nil {
		return err
	}

	return nil
}
