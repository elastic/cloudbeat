// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package vulnerability

import (
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"time"

	"github.com/elastic/beats/v7/libbeat/beat"
	"github.com/elastic/elastic-agent-libs/logp"
	"github.com/elastic/elastic-agent-libs/mapstr"

	db_types "github.com/aquasecurity/trivy-db/pkg/types"
	"github.com/aquasecurity/trivy/pkg/commands/artifact"
	"github.com/aquasecurity/trivy/pkg/flag"
	trivy_types "github.com/aquasecurity/trivy/pkg/types"
	ec2_types "github.com/aws/aws-sdk-go-v2/service/ec2/types"
)

type VulnerabilityEvaluator struct {
	log *logp.Logger
	// TODO: Change to type that includes snapshot for deletion after evaluation
	ch chan beat.Event
}

func NewVulnerabilityEvaluator(log *logp.Logger) VulnerabilityEvaluator {
	log.Debug("VulnerabilityEvaluator: New")
	ch := make(chan beat.Event)
	return VulnerabilityEvaluator{
		log: log,
		ch:  ch,
	}
}

func (f VulnerabilityEvaluator) EvaluateSnapshot(ctx context.Context, snapCh chan ec2_types.Snapshot) {
	f.log.Info("Starting NewVulnerabilityEvaluator.EvaluateSnapshot")
	defer close(f.ch)
	for {
		select {
		case <-ctx.Done():
			f.log.Info("NewVulnerabilityEvaluator.EvaluateSnapshot context canceled")
			return
		case data, ok := <-snapCh:
			if !ok {
				return
			}
			f.evaluate(ctx, data)
		}
	}
}

func (f VulnerabilityEvaluator) evaluate(ctx context.Context, snap ec2_types.Snapshot) {
	f.log.Info("Starting VulnerabilityEvaluator.evaluate")
	f.log.Info("JENIA SNAPS", *snap.Description, *snap.SnapshotId, *snap.Progress, snap.State)
	o, err := ioutil.TempFile("", "")
	if err != nil {
		f.log.Error("VulnerabilityEvaluator.evaluate.TempFile error: ", err)
		return
	}
	defer os.Remove(o.Name())

	opts := flag.Options{
		AWSOptions: flag.AWSOptions{
			// TODO: Take region from config
			Region: "eu-west-1",
		},
		GlobalOptions: flag.GlobalOptions{
			// TODO: Make configurable
			Timeout:  1 * time.Hour,
			Quiet:    false,
			Debug:    true,
			CacheDir: "/tmp/trivy",
		},
		VulnerabilityOptions: flag.VulnerabilityOptions{
			VulnType:      []string{"os", "library"},
			IgnoreUnfixed: false,
		},
		ScanOptions: flag.ScanOptions{
			Target: fmt.Sprint("ebs:", *snap.SnapshotId),
			// Target:         "ebs:snap-07a4a228a916368c5",
			// Target:         "file:snap-07a4a228a916368c5",
			SecurityChecks: []string{"vuln"},
			RekorURL:       "https://rekor.sigstore.dev",
		},
		DBOptions: flag.DBOptions{
			DBRepository: "ghcr.io/aquasecurity/trivy-db",
		},
		ReportOptions: flag.ReportOptions{
			Output:     o,
			Format:     "json",
			Severities: []db_types.Severity{0, 1, 2, 3, 4},
		},
	}

	f.log.Info("VulnerabilityEvaluator.evaluate.NewRunner")
	r, err := artifact.NewRunner(ctx, opts)
	if err != nil {
		f.log.Error("VulnerabilityEvaluator.evaluate.NewRunner error: ", err)
		return
	}

	f.log.Info("VulnerabilityEvaluator.evaluate.ScanVM")
	report, err := r.ScanVM(ctx, opts)
	if err != nil {
		f.log.Error("VulnerabilityEvaluator.evaluate.ScanVM error: ", err)
		return
	}

	f.log.Info("VulnerabilityEvaluator.evaluate.Filter")
	report, err = r.Filter(ctx, opts, report)
	if err != nil {
		f.log.Error("VulnerabilityEvaluator.evaluate.Filter error: ", err)
		return
	}

	f.log.Info("VulnerabilityEvaluator.evaluate.Report")
	err = r.Report(opts, report)
	if err != nil {
		f.log.Error("VulnerabilityEvaluator.evaluate.Report error: ", err)
		return
	}

	f.log.Info("VulnerabilityEvaluator.evaluate.jsonFile")
	jsonFile, err := os.Open(o.Name())
	if err != nil {
		f.log.Error("VulnerabilityEvaluator.evaluate.jsonFile error: ", err)
		return
	}

	defer jsonFile.Close()
	f.log.Info("VulnerabilityEvaluator.evaluate.ReadAll")
	byteValue, _ := ioutil.ReadAll(jsonFile)
	var result trivy_types.Report
	json.Unmarshal([]byte(byteValue), &result)

	// evn, _ := json.Marshal(result)
	// f.log.Info("VulnerabilityEvaluator.evaluate.JENIARES", string(evn))

	f.ch <- beat.Event{
		Fields: mapstr.M{"result": result},
	}

	f.log.Info("VulnerabilityEvaluator.evaluate.DONE")
}

func (f VulnerabilityEvaluator) GetChan() chan beat.Event {
	return f.ch
}
