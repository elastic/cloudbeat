// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package vulnerability

import (
	"context"
	"strings"
	"time"

	dbTypes "github.com/aquasecurity/trivy-db/pkg/types"
	trivyVul "github.com/aquasecurity/trivy-db/pkg/vulnsrc/vulnerability"
	"github.com/elastic/cloudbeat/dataprovider"
	"github.com/elastic/cloudbeat/resources/fetching"
	"github.com/elastic/cloudbeat/resources/providers/awslib/ec2"
	"github.com/elastic/elastic-agent-libs/logp"

	trivyTypes "github.com/aquasecurity/trivy/pkg/types"
	"github.com/elastic/beats/v7/libbeat/beat"
	libevents "github.com/elastic/beats/v7/libbeat/beat/events"
	"github.com/elastic/cloudbeat/transformer"
	"github.com/elastic/cloudbeat/version"
	"github.com/elastic/elastic-agent-libs/mapstr"
	maps "golang.org/x/exp/maps"
)

type Vulnerability struct {
	Cvss           VendorCVSS  `json:"cvss,omitempty"`
	DataSource     *DataSource `json:"data_source,omitempty"`
	Scanner        Scanner     `json:"scanner,omitempty"`
	Score          Score       `json:"score,omitempty"`
	Package        Package     `json:"package,omitempty"`
	Cwe            []string    `json:"cwe,omitempty"`
	ID             string      `json:"id,omitempty"`
	Title          string      `json:"title,omitempty"`
	Enumeration    string      `json:"enumeration,omitempty"`
	Reference      string      `json:"reference,omitempty"`
	Description    string      `json:"description,omitempty"`
	Severity       string      `json:"severity,omitempty"`
	Classification string      `json:"classification,omitempty"`
	PublishedDate  *time.Time  `json:"published_date,omitempty"`
	ReportId       int64       `json:"report_id,omitempty"`
}

type CVSS struct {
	V2Vector string  `json:"V2Vector,omitempty"`
	V3Vector string  `json:"V3Vector,omitempty"`
	V2Score  float64 `json:"V2Score,omitempty"`
	V3Score  float64 `json:"V3Score,omitempty"`
}

type VendorCVSS map[dbTypes.SourceID]CVSS

type DataSource struct {
	ID   dbTypes.SourceID `json:",omitempty"`
	Name string           `json:",omitempty"`
	URL  string           `json:",omitempty"`
}

type Package struct {
	FixedVersion string `json:"fixed_version,omitempty"`
	Version      string `json:"version,omitempty"`
	Name         string `json:"name,omitempty"`
}

type Scanner struct {
	Version string `json:"version,omitempty"`
	Vendor  string `json:"vendor,omitempty"`
}

type Score struct {
	Base    float64 `json:"base,omitempty"`
	Version string  `json:"version,omitempty"`
}

type Resource struct {
	ID   string `json:"id"`
	Name string `json:"name,omitempty"`
}

const (
	vulScannerVersion   = "v0.35.0"
	vulScannerVendor    = "Trivy"
	vulScoreSystemClass = "CVSS"
	vectorHeader        = "CVSS:"
	vulEcsCategory      = "vulnerability"
	vulIndex            = "logs-cloud_security_posture.vulnerabilities-default"
)

type EventsCreator struct {
	log                *logp.Logger
	commonDataProvider dataprovider.CommonDataProvider
	ch                 chan beat.Event
}

func NewEventsCreator(log *logp.Logger, cdp dataprovider.CommonDataProvider) EventsCreator {
	return EventsCreator{
		log:                log,
		commonDataProvider: cdp,
		ch:                 make(chan beat.Event),
	}
}

// TODO: Replace sequence with more generic approach
func (e EventsCreator) CreateEvents(ctx context.Context, scanResults chan Result) {
	defer close(e.ch)
	for {
		select {
		case <-ctx.Done():
			e.log.Info("EventsCreator.CreateEvents context canceled")
			return
		case data, ok := <-scanResults:
			if !ok {
				e.log.Info("EventsCreator.CreateEvents channel is closed")
				return
			}
			e.ch <- e.generateEvent(data.reportResult, data.vulnerability, data.snapshot, data.seq)
		}
	}

}

func (e EventsCreator) GetChan() chan beat.Event {
	return e.ch
}

func (e EventsCreator) generateEvent(reportResult trivyTypes.Result, vul trivyTypes.DetectedVulnerability, snap ec2.EBSSnapshot, seq time.Time) beat.Event {
	timestamp := time.Now().UTC()
	sequence := seq.Unix()
	event := beat.Event{
		// TODO: Maybe configure or get from somewhere else?
		Meta:      mapstr.M{libevents.FieldMetaIndex: vulIndex},
		Timestamp: timestamp,
		Fields: mapstr.M{
			"cloudbeat": version.CloudbeatVersion(),
			// TODO: Replace sequence with more generic approach
			"event": transformer.BuildECSEvent(sequence, timestamp, []string{vulEcsCategory}),
			"resource": Resource{
				ID:   snap.Instance.GetResourceId(),
				Name: snap.Instance.GetResourceName(),
			},
			"target": reportResult.Target,
			"class":  reportResult.Class,
			"type":   reportResult.Type,
			"vulnerability": Vulnerability{
				// TODO: Replace sequence with more generic approach
				// TODO: Do we need to add the ReportID duplication if we already have the sequence in event?
				ReportId:   sequence,
				Cvss:       getCVSS(vul),
				DataSource: getDataSource(vul),
				Scanner: Scanner{
					// TODO: Populate with what?
					Version: vulScannerVersion,
					Vendor:  vulScannerVendor,
				},
				Score: Score{
					Base:    e.getCVSSScore(vul),
					Version: e.getCVSSVersion(vul),
				},
				Package: Package{
					FixedVersion: vul.FixedVersion,
					Name:         vul.PkgName,
					Version:      vul.InstalledVersion,
				},
				Cwe:            vul.CweIDs,
				ID:             vul.VulnerabilityID,
				Title:          vul.Title,
				Enumeration:    getIdentifierType(vul.VulnerabilityID),
				Reference:      vul.PrimaryURL,
				Description:    vul.Description,
				Severity:       vul.Severity,
				Classification: vulScoreSystemClass,
				PublishedDate:  vul.PublishedDate,
			},
		},
	}

	err := e.commonDataProvider.EnrichEvent(&event, fetching.ResourceMetadata{Region: snap.Instance.Region})
	if err != nil {
		e.log.Errorf("failed to enrich event: %v", err)
	}

	return event
}

func getIdentifierType(id string) string {
	s := strings.Split(id, "-")
	if len(s) == 0 {
		return ""
	}

	return s[0]
}

func (e EventsCreator) getCVSSVersion(vul trivyTypes.DetectedVulnerability) string {
	v := e.getCVSSVector(vul)
	if v == "" {
		e.log.Warnf("No CVSS vector found for vulnerability: %s", vul.VulnerabilityID)
		return ""
	}

	parts := strings.Split(v, "/")
	for _, part := range parts {
		if strings.HasPrefix(part, vectorHeader) {
			// Extract the number after "CVSS:"
			version := strings.TrimPrefix(part, vectorHeader)
			return version
		}
	}

	e.log.Warnf("no CVSS version found in vector: %s fallback to v2", v)
	return "2.0"
}

func (e EventsCreator) getCVSSVector(vul trivyTypes.DetectedVulnerability) string {
	var zeroVal string
	if v := getCVSSValue(vul, func(cvss dbTypes.CVSS) string { return cvss.V3Vector }, zeroVal); v != zeroVal {
		return v
	}

	e.log.Debugf("No CVSS v3 vector found for vulnerability: %s, fallback to v2", vul.VulnerabilityID)
	return getCVSSValue(vul, func(cvss dbTypes.CVSS) string { return cvss.V2Vector }, zeroVal)
}

func (e EventsCreator) getCVSSScore(vul trivyTypes.DetectedVulnerability) float64 {
	var zeroVal float64
	if v := getCVSSValue(vul, func(cvss dbTypes.CVSS) float64 { return cvss.V3Score }, zeroVal); v != zeroVal {
		return v
	}

	e.log.Debugf("No CVSS v3 score found for vulnerability: %s, fallback to v2", vul.VulnerabilityID)
	return getCVSSValue(vul, func(cvss dbTypes.CVSS) float64 { return cvss.V2Score }, zeroVal)
}

func getCVSSValue[T comparable](vul trivyTypes.DetectedVulnerability, value func(cvss dbTypes.CVSS) T, zeroVal T) T {
	// Get all the sources
	sources := maps.Keys(vul.CVSS)
	if len(sources) == 0 {
		return zeroVal
	}

	// Detect the data source
	var source dbTypes.SourceID
	if vul.DataSource != nil {
		source = vul.DataSource.ID
	}

	// Attempt to pull detected data source
	if cvss, ok := vul.CVSS[source]; ok {
		return value(cvss)
	}

	// Try NVD as a fallback if it exists
	if cvss, ok := vul.CVSS[trivyVul.NVD]; ok {
		return value(cvss)
	}

	// Attempt to pull any other data source
	for _, s := range sources {
		if cvss, ok := vul.CVSS[s]; ok {
			return value(cvss)
		}
	}

	return zeroVal
}

// https://github.com/elastic/cloudbeat/pull/848#discussion_r1165239774
func getCVSS(vul trivyTypes.DetectedVulnerability) VendorCVSS {
	c := make(map[dbTypes.SourceID]CVSS)
	if len(vul.CVSS) == 0 {
		return c
	}

	for k, v := range vul.CVSS {
		c[k] = CVSS{
			V2Vector: v.V2Vector,
			V3Vector: v.V3Vector,
			V2Score:  v.V2Score,
			V3Score:  v.V3Score,
		}
	}

	return c
}

// https://github.com/elastic/cloudbeat/pull/848#discussion_r1165239774
func getDataSource(vul trivyTypes.DetectedVulnerability) *DataSource {
	if vul.DataSource == nil {
		return nil
	}

	return &DataSource{
		ID:   vul.DataSource.ID,
		Name: vul.DataSource.Name,
		URL:  vul.DataSource.URL,
	}
}
