// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package vulnerability

import (
	"strings"
	"time"

	db_types "github.com/aquasecurity/trivy-db/pkg/types"
	trivy_types "github.com/aquasecurity/trivy/pkg/types"
	"github.com/elastic/beats/v7/libbeat/beat"
	libevents "github.com/elastic/beats/v7/libbeat/beat/events"
	"github.com/elastic/cloudbeat/resources/providers/awslib/ec2"
	"github.com/elastic/cloudbeat/transformer"
	"github.com/elastic/cloudbeat/version"
	"github.com/elastic/elastic-agent-libs/mapstr"
)

type Vulnerability struct {
	Cvss           VendorCVSS `json:"cvss,omitempty"`
	DataSource     DataSource `json:"data_source,omitempty"`
	Scanner        Scanner    `json:"scanner,omitempty"`
	Score          Score      `json:"score,omitempty"`
	Package        Package    `json:"package,omitempty"`
	Cwe            []string   `json:"cwe,omitempty"`
	ID             string     `json:"id,omitempty"`
	Title          string     `json:"title,omitempty"`
	Enumeration    string     `json:"enumeration,omitempty"`
	Reference      string     `json:"reference,omitempty"`
	Description    string     `json:"description,omitempty"`
	Severity       string     `json:"severity,omitempty"`
	Classification string     `json:"classification,omitempty"`
	PublishedDate  time.Time  `json:"published_date,omitempty"`
	ReportId       int64      `json:"report_id,omitempty"`
}

type CVSS struct {
	V2Vector string  `json:"V2Vector,omitempty"`
	V3Vector string  `json:"V3Vector,omitempty"`
	V2Score  float64 `json:"V2Score,omitempty"`
	V3Score  float64 `json:"V3Score,omitempty"`
}

// SourceID represents data source such as NVD.
type SourceID string

type VendorCVSS map[SourceID]CVSS

type DataSource struct {
	ID   SourceID `json:",omitempty"`
	Name string   `json:",omitempty"`
	URL  string   `json:",omitempty"`
}

type Package struct {
	FixedVersion string `json:"fixed_version,omitempty"`
	Version      string `json:"version,omitempty"`
	Name         string `json:"name,omitempty"`
}

type Scanner struct {
	Version string `json:"version,omitempty"`
	Vendor  string `json:"vendor,omitempty"`
}

type Score struct {
	Impact  float64 `json:"impact,omitempty"`
	Base    float64 `json:"base,omitempty"`
	Version string  `json:"version,omitempty"`
}

type Resource struct {
	ID   string `json:"id"`
	Name string `json:"name,omitempty"`
}

const (
	vulScannerVersion     = "v0.35.0"
	vulScannerVendor      = "Trivy"
	vulScoreSystemClass   = "CVSS"
	vulScoreSource        = "nvd"
	vulScoreSourceVersion = "3.0"
	vulEcsCategory        = "vulnerability"
	vulIndex              = "logs-cloud_security_posture.vulnerabilities-default"
)

// TODO: Replace sequence with more generic approach
func createVulnerabilityEvent(reportResult trivy_types.Result, vul trivy_types.DetectedVulnerability, ins ec2.Ec2Instance, seq time.Time) beat.Event {
	timestamp := time.Now().UTC()
	sequence := seq.Unix()
	cvssScore := getCVSSScore(vul, vulScoreSource)
	return beat.Event{
		// TODO: Maybe configure or get from somewhere else?
		Meta:      mapstr.M{libevents.FieldMetaIndex: vulIndex},
		Timestamp: timestamp,
		Fields: mapstr.M{
			"cloudbeat": version.CloudbeatVersion(),
			// TODO: Replace sequence with more generic approach
			"event": transformer.BuildECSEvent(sequence, timestamp, []string{vulEcsCategory}),
			"resource": Resource{
				ID:   ins.GetResourceId(),
				Name: ins.GetResourceName(),
			},
			"target": reportResult.Target,
			"class":  reportResult.Class,
			"type":   reportResult.Type,
			"vulnerability": Vulnerability{
				// TODO: Replace sequence with more generic approach
				// TODO: Do we need to add the ReportID duplication if we already have the sequence in event?
				ReportId:   sequence,
				Cvss:       getCVSS(vul),
				DataSource: getDataSource(vul),
				Scanner: Scanner{
					// TODO: Populate with what?
					Version: vulScannerVersion,
					Vendor:  vulScannerVendor,
				},
				Score: Score{
					Impact:  cvssScore,
					Base:    cvssScore,
					Version: vulScoreSourceVersion,
				},
				Package: Package{
					FixedVersion: vul.FixedVersion,
					Name:         vul.PkgName,
					Version:      vul.InstalledVersion,
				},
				Cwe:            vul.CweIDs,
				ID:             vul.VulnerabilityID,
				Title:          vul.Title,
				Enumeration:    getIdentifierType(vul.VulnerabilityID),
				Reference:      vul.PrimaryURL,
				Description:    vul.Description,
				Severity:       vul.Severity,
				Classification: vulScoreSystemClass,
				PublishedDate:  getPublishedDate(vul),
			},
		},
	}
}

func getIdentifierType(id string) string {
	return strings.Split(id, "-")[0]
}

func getCVSSScore(vul trivy_types.DetectedVulnerability, source db_types.SourceID) float64 {
	if cvss, ok := vul.CVSS[source]; ok {
		return cvss.V3Score
	}

	return 0
}

// https://github.com/elastic/cloudbeat/pull/848#discussion_r1165239774
func getCVSS(vul trivy_types.DetectedVulnerability) VendorCVSS {
	c := make(map[SourceID]CVSS)
	if len(vul.CVSS) == 0 {
		return c
	}

	for k, v := range vul.CVSS {
		c[SourceID(k)] = CVSS{
			V2Vector: v.V2Vector,
			V3Vector: v.V3Vector,
			V2Score:  v.V2Score,
			V3Score:  v.V3Score,
		}
	}

	return c
}

// https://github.com/elastic/cloudbeat/pull/848#discussion_r1165239774
func getDataSource(vul trivy_types.DetectedVulnerability) DataSource {
	return DataSource{
		ID:   SourceID(vul.DataSource.ID),
		Name: vul.DataSource.Name,
		URL:  vul.DataSource.URL,
	}
}

func getPublishedDate(vul trivy_types.DetectedVulnerability) time.Time {
	if vul.PublishedDate == nil {
		return time.Time{}
	}
	return *vul.PublishedDate
}
