// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
//go:build !release

// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package iam

import (
	"context"

	"github.com/aws/aws-sdk-go-v2/service/accessanalyzer"
	"github.com/aws/aws-sdk-go-v2/service/iam"
	"github.com/elastic/cloudbeat/internal/resources/providers/awslib"
	mock "github.com/stretchr/testify/mock"
)

// NewMockAccessManagement creates a new instance of MockAccessManagement. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockAccessManagement(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockAccessManagement {
	mock := &MockAccessManagement{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockAccessManagement is an autogenerated mock type for the AccessManagement type
type MockAccessManagement struct {
	mock.Mock
}

type MockAccessManagement_Expecter struct {
	mock *mock.Mock
}

func (_m *MockAccessManagement) EXPECT() *MockAccessManagement_Expecter {
	return &MockAccessManagement_Expecter{mock: &_m.Mock}
}

// GetAccessAnalyzers provides a mock function for the type MockAccessManagement
func (_mock *MockAccessManagement) GetAccessAnalyzers(ctx context.Context) (awslib.AwsResource, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetAccessAnalyzers")
	}

	var r0 awslib.AwsResource
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (awslib.AwsResource, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) awslib.AwsResource); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(awslib.AwsResource)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAccessManagement_GetAccessAnalyzers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccessAnalyzers'
type MockAccessManagement_GetAccessAnalyzers_Call struct {
	*mock.Call
}

// GetAccessAnalyzers is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockAccessManagement_Expecter) GetAccessAnalyzers(ctx interface{}) *MockAccessManagement_GetAccessAnalyzers_Call {
	return &MockAccessManagement_GetAccessAnalyzers_Call{Call: _e.mock.On("GetAccessAnalyzers", ctx)}
}

func (_c *MockAccessManagement_GetAccessAnalyzers_Call) Run(run func(ctx context.Context)) *MockAccessManagement_GetAccessAnalyzers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockAccessManagement_GetAccessAnalyzers_Call) Return(awsResource awslib.AwsResource, err error) *MockAccessManagement_GetAccessAnalyzers_Call {
	_c.Call.Return(awsResource, err)
	return _c
}

func (_c *MockAccessManagement_GetAccessAnalyzers_Call) RunAndReturn(run func(ctx context.Context) (awslib.AwsResource, error)) *MockAccessManagement_GetAccessAnalyzers_Call {
	_c.Call.Return(run)
	return _c
}

// GetIAMRolePermissions provides a mock function for the type MockAccessManagement
func (_mock *MockAccessManagement) GetIAMRolePermissions(ctx context.Context, roleName string) ([]RolePolicyInfo, error) {
	ret := _mock.Called(ctx, roleName)

	if len(ret) == 0 {
		panic("no return value specified for GetIAMRolePermissions")
	}

	var r0 []RolePolicyInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]RolePolicyInfo, error)); ok {
		return returnFunc(ctx, roleName)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []RolePolicyInfo); ok {
		r0 = returnFunc(ctx, roleName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]RolePolicyInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, roleName)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAccessManagement_GetIAMRolePermissions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIAMRolePermissions'
type MockAccessManagement_GetIAMRolePermissions_Call struct {
	*mock.Call
}

// GetIAMRolePermissions is a helper method to define mock.On call
//   - ctx context.Context
//   - roleName string
func (_e *MockAccessManagement_Expecter) GetIAMRolePermissions(ctx interface{}, roleName interface{}) *MockAccessManagement_GetIAMRolePermissions_Call {
	return &MockAccessManagement_GetIAMRolePermissions_Call{Call: _e.mock.On("GetIAMRolePermissions", ctx, roleName)}
}

func (_c *MockAccessManagement_GetIAMRolePermissions_Call) Run(run func(ctx context.Context, roleName string)) *MockAccessManagement_GetIAMRolePermissions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAccessManagement_GetIAMRolePermissions_Call) Return(rolePolicyInfos []RolePolicyInfo, err error) *MockAccessManagement_GetIAMRolePermissions_Call {
	_c.Call.Return(rolePolicyInfos, err)
	return _c
}

func (_c *MockAccessManagement_GetIAMRolePermissions_Call) RunAndReturn(run func(ctx context.Context, roleName string) ([]RolePolicyInfo, error)) *MockAccessManagement_GetIAMRolePermissions_Call {
	_c.Call.Return(run)
	return _c
}

// GetPasswordPolicy provides a mock function for the type MockAccessManagement
func (_mock *MockAccessManagement) GetPasswordPolicy(ctx context.Context) (awslib.AwsResource, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetPasswordPolicy")
	}

	var r0 awslib.AwsResource
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (awslib.AwsResource, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) awslib.AwsResource); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(awslib.AwsResource)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAccessManagement_GetPasswordPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPasswordPolicy'
type MockAccessManagement_GetPasswordPolicy_Call struct {
	*mock.Call
}

// GetPasswordPolicy is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockAccessManagement_Expecter) GetPasswordPolicy(ctx interface{}) *MockAccessManagement_GetPasswordPolicy_Call {
	return &MockAccessManagement_GetPasswordPolicy_Call{Call: _e.mock.On("GetPasswordPolicy", ctx)}
}

func (_c *MockAccessManagement_GetPasswordPolicy_Call) Run(run func(ctx context.Context)) *MockAccessManagement_GetPasswordPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockAccessManagement_GetPasswordPolicy_Call) Return(awsResource awslib.AwsResource, err error) *MockAccessManagement_GetPasswordPolicy_Call {
	_c.Call.Return(awsResource, err)
	return _c
}

func (_c *MockAccessManagement_GetPasswordPolicy_Call) RunAndReturn(run func(ctx context.Context) (awslib.AwsResource, error)) *MockAccessManagement_GetPasswordPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// GetPolicies provides a mock function for the type MockAccessManagement
func (_mock *MockAccessManagement) GetPolicies(ctx context.Context) ([]awslib.AwsResource, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetPolicies")
	}

	var r0 []awslib.AwsResource
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]awslib.AwsResource, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []awslib.AwsResource); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]awslib.AwsResource)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAccessManagement_GetPolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPolicies'
type MockAccessManagement_GetPolicies_Call struct {
	*mock.Call
}

// GetPolicies is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockAccessManagement_Expecter) GetPolicies(ctx interface{}) *MockAccessManagement_GetPolicies_Call {
	return &MockAccessManagement_GetPolicies_Call{Call: _e.mock.On("GetPolicies", ctx)}
}

func (_c *MockAccessManagement_GetPolicies_Call) Run(run func(ctx context.Context)) *MockAccessManagement_GetPolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockAccessManagement_GetPolicies_Call) Return(awsResources []awslib.AwsResource, err error) *MockAccessManagement_GetPolicies_Call {
	_c.Call.Return(awsResources, err)
	return _c
}

func (_c *MockAccessManagement_GetPolicies_Call) RunAndReturn(run func(ctx context.Context) ([]awslib.AwsResource, error)) *MockAccessManagement_GetPolicies_Call {
	_c.Call.Return(run)
	return _c
}

// GetUsers provides a mock function for the type MockAccessManagement
func (_mock *MockAccessManagement) GetUsers(ctx context.Context) ([]awslib.AwsResource, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetUsers")
	}

	var r0 []awslib.AwsResource
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]awslib.AwsResource, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []awslib.AwsResource); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]awslib.AwsResource)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAccessManagement_GetUsers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUsers'
type MockAccessManagement_GetUsers_Call struct {
	*mock.Call
}

// GetUsers is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockAccessManagement_Expecter) GetUsers(ctx interface{}) *MockAccessManagement_GetUsers_Call {
	return &MockAccessManagement_GetUsers_Call{Call: _e.mock.On("GetUsers", ctx)}
}

func (_c *MockAccessManagement_GetUsers_Call) Run(run func(ctx context.Context)) *MockAccessManagement_GetUsers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockAccessManagement_GetUsers_Call) Return(awsResources []awslib.AwsResource, err error) *MockAccessManagement_GetUsers_Call {
	_c.Call.Return(awsResources, err)
	return _c
}

func (_c *MockAccessManagement_GetUsers_Call) RunAndReturn(run func(ctx context.Context) ([]awslib.AwsResource, error)) *MockAccessManagement_GetUsers_Call {
	_c.Call.Return(run)
	return _c
}

// ListServerCertificates provides a mock function for the type MockAccessManagement
func (_mock *MockAccessManagement) ListServerCertificates(ctx context.Context) (awslib.AwsResource, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListServerCertificates")
	}

	var r0 awslib.AwsResource
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (awslib.AwsResource, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) awslib.AwsResource); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(awslib.AwsResource)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAccessManagement_ListServerCertificates_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListServerCertificates'
type MockAccessManagement_ListServerCertificates_Call struct {
	*mock.Call
}

// ListServerCertificates is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockAccessManagement_Expecter) ListServerCertificates(ctx interface{}) *MockAccessManagement_ListServerCertificates_Call {
	return &MockAccessManagement_ListServerCertificates_Call{Call: _e.mock.On("ListServerCertificates", ctx)}
}

func (_c *MockAccessManagement_ListServerCertificates_Call) Run(run func(ctx context.Context)) *MockAccessManagement_ListServerCertificates_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockAccessManagement_ListServerCertificates_Call) Return(awsResource awslib.AwsResource, err error) *MockAccessManagement_ListServerCertificates_Call {
	_c.Call.Return(awsResource, err)
	return _c
}

func (_c *MockAccessManagement_ListServerCertificates_Call) RunAndReturn(run func(ctx context.Context) (awslib.AwsResource, error)) *MockAccessManagement_ListServerCertificates_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockClient creates a new instance of MockClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockClient {
	mock := &MockClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockClient is an autogenerated mock type for the Client type
type MockClient struct {
	mock.Mock
}

type MockClient_Expecter struct {
	mock *mock.Mock
}

func (_m *MockClient) EXPECT() *MockClient_Expecter {
	return &MockClient_Expecter{mock: &_m.Mock}
}

// GenerateCredentialReport provides a mock function for the type MockClient
func (_mock *MockClient) GenerateCredentialReport(ctx context.Context, params *iam.GenerateCredentialReportInput, optFns ...func(*iam.Options)) (*iam.GenerateCredentialReportOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GenerateCredentialReport")
	}

	var r0 *iam.GenerateCredentialReportOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.GenerateCredentialReportInput, ...func(*iam.Options)) (*iam.GenerateCredentialReportOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.GenerateCredentialReportInput, ...func(*iam.Options)) *iam.GenerateCredentialReportOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GenerateCredentialReportOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *iam.GenerateCredentialReportInput, ...func(*iam.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_GenerateCredentialReport_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GenerateCredentialReport'
type MockClient_GenerateCredentialReport_Call struct {
	*mock.Call
}

// GenerateCredentialReport is a helper method to define mock.On call
//   - ctx context.Context
//   - params *iam.GenerateCredentialReportInput
//   - optFns ...func(*iam.Options)
func (_e *MockClient_Expecter) GenerateCredentialReport(ctx interface{}, params interface{}, optFns ...interface{}) *MockClient_GenerateCredentialReport_Call {
	return &MockClient_GenerateCredentialReport_Call{Call: _e.mock.On("GenerateCredentialReport",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockClient_GenerateCredentialReport_Call) Run(run func(ctx context.Context, params *iam.GenerateCredentialReportInput, optFns ...func(*iam.Options))) *MockClient_GenerateCredentialReport_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *iam.GenerateCredentialReportInput
		if args[1] != nil {
			arg1 = args[1].(*iam.GenerateCredentialReportInput)
		}
		var arg2 []func(*iam.Options)
		var variadicArgs []func(*iam.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*iam.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockClient_GenerateCredentialReport_Call) Return(generateCredentialReportOutput *iam.GenerateCredentialReportOutput, err error) *MockClient_GenerateCredentialReport_Call {
	_c.Call.Return(generateCredentialReportOutput, err)
	return _c
}

func (_c *MockClient_GenerateCredentialReport_Call) RunAndReturn(run func(ctx context.Context, params *iam.GenerateCredentialReportInput, optFns ...func(*iam.Options)) (*iam.GenerateCredentialReportOutput, error)) *MockClient_GenerateCredentialReport_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccessKeyLastUsed provides a mock function for the type MockClient
func (_mock *MockClient) GetAccessKeyLastUsed(ctx context.Context, params *iam.GetAccessKeyLastUsedInput, optFns ...func(*iam.Options)) (*iam.GetAccessKeyLastUsedOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetAccessKeyLastUsed")
	}

	var r0 *iam.GetAccessKeyLastUsedOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.GetAccessKeyLastUsedInput, ...func(*iam.Options)) (*iam.GetAccessKeyLastUsedOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.GetAccessKeyLastUsedInput, ...func(*iam.Options)) *iam.GetAccessKeyLastUsedOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GetAccessKeyLastUsedOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *iam.GetAccessKeyLastUsedInput, ...func(*iam.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_GetAccessKeyLastUsed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccessKeyLastUsed'
type MockClient_GetAccessKeyLastUsed_Call struct {
	*mock.Call
}

// GetAccessKeyLastUsed is a helper method to define mock.On call
//   - ctx context.Context
//   - params *iam.GetAccessKeyLastUsedInput
//   - optFns ...func(*iam.Options)
func (_e *MockClient_Expecter) GetAccessKeyLastUsed(ctx interface{}, params interface{}, optFns ...interface{}) *MockClient_GetAccessKeyLastUsed_Call {
	return &MockClient_GetAccessKeyLastUsed_Call{Call: _e.mock.On("GetAccessKeyLastUsed",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockClient_GetAccessKeyLastUsed_Call) Run(run func(ctx context.Context, params *iam.GetAccessKeyLastUsedInput, optFns ...func(*iam.Options))) *MockClient_GetAccessKeyLastUsed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *iam.GetAccessKeyLastUsedInput
		if args[1] != nil {
			arg1 = args[1].(*iam.GetAccessKeyLastUsedInput)
		}
		var arg2 []func(*iam.Options)
		var variadicArgs []func(*iam.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*iam.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockClient_GetAccessKeyLastUsed_Call) Return(getAccessKeyLastUsedOutput *iam.GetAccessKeyLastUsedOutput, err error) *MockClient_GetAccessKeyLastUsed_Call {
	_c.Call.Return(getAccessKeyLastUsedOutput, err)
	return _c
}

func (_c *MockClient_GetAccessKeyLastUsed_Call) RunAndReturn(run func(ctx context.Context, params *iam.GetAccessKeyLastUsedInput, optFns ...func(*iam.Options)) (*iam.GetAccessKeyLastUsedOutput, error)) *MockClient_GetAccessKeyLastUsed_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccountPasswordPolicy provides a mock function for the type MockClient
func (_mock *MockClient) GetAccountPasswordPolicy(ctx context.Context, params *iam.GetAccountPasswordPolicyInput, optFns ...func(*iam.Options)) (*iam.GetAccountPasswordPolicyOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetAccountPasswordPolicy")
	}

	var r0 *iam.GetAccountPasswordPolicyOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.GetAccountPasswordPolicyInput, ...func(*iam.Options)) (*iam.GetAccountPasswordPolicyOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.GetAccountPasswordPolicyInput, ...func(*iam.Options)) *iam.GetAccountPasswordPolicyOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GetAccountPasswordPolicyOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *iam.GetAccountPasswordPolicyInput, ...func(*iam.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_GetAccountPasswordPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccountPasswordPolicy'
type MockClient_GetAccountPasswordPolicy_Call struct {
	*mock.Call
}

// GetAccountPasswordPolicy is a helper method to define mock.On call
//   - ctx context.Context
//   - params *iam.GetAccountPasswordPolicyInput
//   - optFns ...func(*iam.Options)
func (_e *MockClient_Expecter) GetAccountPasswordPolicy(ctx interface{}, params interface{}, optFns ...interface{}) *MockClient_GetAccountPasswordPolicy_Call {
	return &MockClient_GetAccountPasswordPolicy_Call{Call: _e.mock.On("GetAccountPasswordPolicy",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockClient_GetAccountPasswordPolicy_Call) Run(run func(ctx context.Context, params *iam.GetAccountPasswordPolicyInput, optFns ...func(*iam.Options))) *MockClient_GetAccountPasswordPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *iam.GetAccountPasswordPolicyInput
		if args[1] != nil {
			arg1 = args[1].(*iam.GetAccountPasswordPolicyInput)
		}
		var arg2 []func(*iam.Options)
		var variadicArgs []func(*iam.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*iam.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockClient_GetAccountPasswordPolicy_Call) Return(getAccountPasswordPolicyOutput *iam.GetAccountPasswordPolicyOutput, err error) *MockClient_GetAccountPasswordPolicy_Call {
	_c.Call.Return(getAccountPasswordPolicyOutput, err)
	return _c
}

func (_c *MockClient_GetAccountPasswordPolicy_Call) RunAndReturn(run func(ctx context.Context, params *iam.GetAccountPasswordPolicyInput, optFns ...func(*iam.Options)) (*iam.GetAccountPasswordPolicyOutput, error)) *MockClient_GetAccountPasswordPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// GetCredentialReport provides a mock function for the type MockClient
func (_mock *MockClient) GetCredentialReport(ctx context.Context, params *iam.GetCredentialReportInput, optFns ...func(*iam.Options)) (*iam.GetCredentialReportOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetCredentialReport")
	}

	var r0 *iam.GetCredentialReportOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.GetCredentialReportInput, ...func(*iam.Options)) (*iam.GetCredentialReportOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.GetCredentialReportInput, ...func(*iam.Options)) *iam.GetCredentialReportOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GetCredentialReportOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *iam.GetCredentialReportInput, ...func(*iam.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_GetCredentialReport_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCredentialReport'
type MockClient_GetCredentialReport_Call struct {
	*mock.Call
}

// GetCredentialReport is a helper method to define mock.On call
//   - ctx context.Context
//   - params *iam.GetCredentialReportInput
//   - optFns ...func(*iam.Options)
func (_e *MockClient_Expecter) GetCredentialReport(ctx interface{}, params interface{}, optFns ...interface{}) *MockClient_GetCredentialReport_Call {
	return &MockClient_GetCredentialReport_Call{Call: _e.mock.On("GetCredentialReport",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockClient_GetCredentialReport_Call) Run(run func(ctx context.Context, params *iam.GetCredentialReportInput, optFns ...func(*iam.Options))) *MockClient_GetCredentialReport_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *iam.GetCredentialReportInput
		if args[1] != nil {
			arg1 = args[1].(*iam.GetCredentialReportInput)
		}
		var arg2 []func(*iam.Options)
		var variadicArgs []func(*iam.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*iam.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockClient_GetCredentialReport_Call) Return(getCredentialReportOutput *iam.GetCredentialReportOutput, err error) *MockClient_GetCredentialReport_Call {
	_c.Call.Return(getCredentialReportOutput, err)
	return _c
}

func (_c *MockClient_GetCredentialReport_Call) RunAndReturn(run func(ctx context.Context, params *iam.GetCredentialReportInput, optFns ...func(*iam.Options)) (*iam.GetCredentialReportOutput, error)) *MockClient_GetCredentialReport_Call {
	_c.Call.Return(run)
	return _c
}

// GetPolicy provides a mock function for the type MockClient
func (_mock *MockClient) GetPolicy(ctx context.Context, params *iam.GetPolicyInput, optFns ...func(*iam.Options)) (*iam.GetPolicyOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetPolicy")
	}

	var r0 *iam.GetPolicyOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.GetPolicyInput, ...func(*iam.Options)) (*iam.GetPolicyOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.GetPolicyInput, ...func(*iam.Options)) *iam.GetPolicyOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GetPolicyOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *iam.GetPolicyInput, ...func(*iam.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_GetPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPolicy'
type MockClient_GetPolicy_Call struct {
	*mock.Call
}

// GetPolicy is a helper method to define mock.On call
//   - ctx context.Context
//   - params *iam.GetPolicyInput
//   - optFns ...func(*iam.Options)
func (_e *MockClient_Expecter) GetPolicy(ctx interface{}, params interface{}, optFns ...interface{}) *MockClient_GetPolicy_Call {
	return &MockClient_GetPolicy_Call{Call: _e.mock.On("GetPolicy",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockClient_GetPolicy_Call) Run(run func(ctx context.Context, params *iam.GetPolicyInput, optFns ...func(*iam.Options))) *MockClient_GetPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *iam.GetPolicyInput
		if args[1] != nil {
			arg1 = args[1].(*iam.GetPolicyInput)
		}
		var arg2 []func(*iam.Options)
		var variadicArgs []func(*iam.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*iam.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockClient_GetPolicy_Call) Return(getPolicyOutput *iam.GetPolicyOutput, err error) *MockClient_GetPolicy_Call {
	_c.Call.Return(getPolicyOutput, err)
	return _c
}

func (_c *MockClient_GetPolicy_Call) RunAndReturn(run func(ctx context.Context, params *iam.GetPolicyInput, optFns ...func(*iam.Options)) (*iam.GetPolicyOutput, error)) *MockClient_GetPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// GetPolicyVersion provides a mock function for the type MockClient
func (_mock *MockClient) GetPolicyVersion(ctx context.Context, params *iam.GetPolicyVersionInput, optFns ...func(*iam.Options)) (*iam.GetPolicyVersionOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetPolicyVersion")
	}

	var r0 *iam.GetPolicyVersionOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.GetPolicyVersionInput, ...func(*iam.Options)) (*iam.GetPolicyVersionOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.GetPolicyVersionInput, ...func(*iam.Options)) *iam.GetPolicyVersionOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GetPolicyVersionOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *iam.GetPolicyVersionInput, ...func(*iam.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_GetPolicyVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPolicyVersion'
type MockClient_GetPolicyVersion_Call struct {
	*mock.Call
}

// GetPolicyVersion is a helper method to define mock.On call
//   - ctx context.Context
//   - params *iam.GetPolicyVersionInput
//   - optFns ...func(*iam.Options)
func (_e *MockClient_Expecter) GetPolicyVersion(ctx interface{}, params interface{}, optFns ...interface{}) *MockClient_GetPolicyVersion_Call {
	return &MockClient_GetPolicyVersion_Call{Call: _e.mock.On("GetPolicyVersion",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockClient_GetPolicyVersion_Call) Run(run func(ctx context.Context, params *iam.GetPolicyVersionInput, optFns ...func(*iam.Options))) *MockClient_GetPolicyVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *iam.GetPolicyVersionInput
		if args[1] != nil {
			arg1 = args[1].(*iam.GetPolicyVersionInput)
		}
		var arg2 []func(*iam.Options)
		var variadicArgs []func(*iam.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*iam.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockClient_GetPolicyVersion_Call) Return(getPolicyVersionOutput *iam.GetPolicyVersionOutput, err error) *MockClient_GetPolicyVersion_Call {
	_c.Call.Return(getPolicyVersionOutput, err)
	return _c
}

func (_c *MockClient_GetPolicyVersion_Call) RunAndReturn(run func(ctx context.Context, params *iam.GetPolicyVersionInput, optFns ...func(*iam.Options)) (*iam.GetPolicyVersionOutput, error)) *MockClient_GetPolicyVersion_Call {
	_c.Call.Return(run)
	return _c
}

// GetRole provides a mock function for the type MockClient
func (_mock *MockClient) GetRole(ctx context.Context, params *iam.GetRoleInput, optFns ...func(*iam.Options)) (*iam.GetRoleOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetRole")
	}

	var r0 *iam.GetRoleOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.GetRoleInput, ...func(*iam.Options)) (*iam.GetRoleOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.GetRoleInput, ...func(*iam.Options)) *iam.GetRoleOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GetRoleOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *iam.GetRoleInput, ...func(*iam.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_GetRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRole'
type MockClient_GetRole_Call struct {
	*mock.Call
}

// GetRole is a helper method to define mock.On call
//   - ctx context.Context
//   - params *iam.GetRoleInput
//   - optFns ...func(*iam.Options)
func (_e *MockClient_Expecter) GetRole(ctx interface{}, params interface{}, optFns ...interface{}) *MockClient_GetRole_Call {
	return &MockClient_GetRole_Call{Call: _e.mock.On("GetRole",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockClient_GetRole_Call) Run(run func(ctx context.Context, params *iam.GetRoleInput, optFns ...func(*iam.Options))) *MockClient_GetRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *iam.GetRoleInput
		if args[1] != nil {
			arg1 = args[1].(*iam.GetRoleInput)
		}
		var arg2 []func(*iam.Options)
		var variadicArgs []func(*iam.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*iam.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockClient_GetRole_Call) Return(getRoleOutput *iam.GetRoleOutput, err error) *MockClient_GetRole_Call {
	_c.Call.Return(getRoleOutput, err)
	return _c
}

func (_c *MockClient_GetRole_Call) RunAndReturn(run func(ctx context.Context, params *iam.GetRoleInput, optFns ...func(*iam.Options)) (*iam.GetRoleOutput, error)) *MockClient_GetRole_Call {
	_c.Call.Return(run)
	return _c
}

// GetRolePolicy provides a mock function for the type MockClient
func (_mock *MockClient) GetRolePolicy(ctx context.Context, params *iam.GetRolePolicyInput, optFns ...func(*iam.Options)) (*iam.GetRolePolicyOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetRolePolicy")
	}

	var r0 *iam.GetRolePolicyOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.GetRolePolicyInput, ...func(*iam.Options)) (*iam.GetRolePolicyOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.GetRolePolicyInput, ...func(*iam.Options)) *iam.GetRolePolicyOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GetRolePolicyOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *iam.GetRolePolicyInput, ...func(*iam.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_GetRolePolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRolePolicy'
type MockClient_GetRolePolicy_Call struct {
	*mock.Call
}

// GetRolePolicy is a helper method to define mock.On call
//   - ctx context.Context
//   - params *iam.GetRolePolicyInput
//   - optFns ...func(*iam.Options)
func (_e *MockClient_Expecter) GetRolePolicy(ctx interface{}, params interface{}, optFns ...interface{}) *MockClient_GetRolePolicy_Call {
	return &MockClient_GetRolePolicy_Call{Call: _e.mock.On("GetRolePolicy",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockClient_GetRolePolicy_Call) Run(run func(ctx context.Context, params *iam.GetRolePolicyInput, optFns ...func(*iam.Options))) *MockClient_GetRolePolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *iam.GetRolePolicyInput
		if args[1] != nil {
			arg1 = args[1].(*iam.GetRolePolicyInput)
		}
		var arg2 []func(*iam.Options)
		var variadicArgs []func(*iam.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*iam.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockClient_GetRolePolicy_Call) Return(getRolePolicyOutput *iam.GetRolePolicyOutput, err error) *MockClient_GetRolePolicy_Call {
	_c.Call.Return(getRolePolicyOutput, err)
	return _c
}

func (_c *MockClient_GetRolePolicy_Call) RunAndReturn(run func(ctx context.Context, params *iam.GetRolePolicyInput, optFns ...func(*iam.Options)) (*iam.GetRolePolicyOutput, error)) *MockClient_GetRolePolicy_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserPolicy provides a mock function for the type MockClient
func (_mock *MockClient) GetUserPolicy(ctx context.Context, params *iam.GetUserPolicyInput, optFns ...func(*iam.Options)) (*iam.GetUserPolicyOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetUserPolicy")
	}

	var r0 *iam.GetUserPolicyOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.GetUserPolicyInput, ...func(*iam.Options)) (*iam.GetUserPolicyOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.GetUserPolicyInput, ...func(*iam.Options)) *iam.GetUserPolicyOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.GetUserPolicyOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *iam.GetUserPolicyInput, ...func(*iam.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_GetUserPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserPolicy'
type MockClient_GetUserPolicy_Call struct {
	*mock.Call
}

// GetUserPolicy is a helper method to define mock.On call
//   - ctx context.Context
//   - params *iam.GetUserPolicyInput
//   - optFns ...func(*iam.Options)
func (_e *MockClient_Expecter) GetUserPolicy(ctx interface{}, params interface{}, optFns ...interface{}) *MockClient_GetUserPolicy_Call {
	return &MockClient_GetUserPolicy_Call{Call: _e.mock.On("GetUserPolicy",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockClient_GetUserPolicy_Call) Run(run func(ctx context.Context, params *iam.GetUserPolicyInput, optFns ...func(*iam.Options))) *MockClient_GetUserPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *iam.GetUserPolicyInput
		if args[1] != nil {
			arg1 = args[1].(*iam.GetUserPolicyInput)
		}
		var arg2 []func(*iam.Options)
		var variadicArgs []func(*iam.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*iam.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockClient_GetUserPolicy_Call) Return(getUserPolicyOutput *iam.GetUserPolicyOutput, err error) *MockClient_GetUserPolicy_Call {
	_c.Call.Return(getUserPolicyOutput, err)
	return _c
}

func (_c *MockClient_GetUserPolicy_Call) RunAndReturn(run func(ctx context.Context, params *iam.GetUserPolicyInput, optFns ...func(*iam.Options)) (*iam.GetUserPolicyOutput, error)) *MockClient_GetUserPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// ListAccessKeys provides a mock function for the type MockClient
func (_mock *MockClient) ListAccessKeys(ctx context.Context, params *iam.ListAccessKeysInput, optFns ...func(*iam.Options)) (*iam.ListAccessKeysOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ListAccessKeys")
	}

	var r0 *iam.ListAccessKeysOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.ListAccessKeysInput, ...func(*iam.Options)) (*iam.ListAccessKeysOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.ListAccessKeysInput, ...func(*iam.Options)) *iam.ListAccessKeysOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListAccessKeysOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *iam.ListAccessKeysInput, ...func(*iam.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_ListAccessKeys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListAccessKeys'
type MockClient_ListAccessKeys_Call struct {
	*mock.Call
}

// ListAccessKeys is a helper method to define mock.On call
//   - ctx context.Context
//   - params *iam.ListAccessKeysInput
//   - optFns ...func(*iam.Options)
func (_e *MockClient_Expecter) ListAccessKeys(ctx interface{}, params interface{}, optFns ...interface{}) *MockClient_ListAccessKeys_Call {
	return &MockClient_ListAccessKeys_Call{Call: _e.mock.On("ListAccessKeys",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockClient_ListAccessKeys_Call) Run(run func(ctx context.Context, params *iam.ListAccessKeysInput, optFns ...func(*iam.Options))) *MockClient_ListAccessKeys_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *iam.ListAccessKeysInput
		if args[1] != nil {
			arg1 = args[1].(*iam.ListAccessKeysInput)
		}
		var arg2 []func(*iam.Options)
		var variadicArgs []func(*iam.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*iam.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockClient_ListAccessKeys_Call) Return(listAccessKeysOutput *iam.ListAccessKeysOutput, err error) *MockClient_ListAccessKeys_Call {
	_c.Call.Return(listAccessKeysOutput, err)
	return _c
}

func (_c *MockClient_ListAccessKeys_Call) RunAndReturn(run func(ctx context.Context, params *iam.ListAccessKeysInput, optFns ...func(*iam.Options)) (*iam.ListAccessKeysOutput, error)) *MockClient_ListAccessKeys_Call {
	_c.Call.Return(run)
	return _c
}

// ListAttachedRolePolicies provides a mock function for the type MockClient
func (_mock *MockClient) ListAttachedRolePolicies(ctx context.Context, params *iam.ListAttachedRolePoliciesInput, optFns ...func(*iam.Options)) (*iam.ListAttachedRolePoliciesOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ListAttachedRolePolicies")
	}

	var r0 *iam.ListAttachedRolePoliciesOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.ListAttachedRolePoliciesInput, ...func(*iam.Options)) (*iam.ListAttachedRolePoliciesOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.ListAttachedRolePoliciesInput, ...func(*iam.Options)) *iam.ListAttachedRolePoliciesOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListAttachedRolePoliciesOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *iam.ListAttachedRolePoliciesInput, ...func(*iam.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_ListAttachedRolePolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListAttachedRolePolicies'
type MockClient_ListAttachedRolePolicies_Call struct {
	*mock.Call
}

// ListAttachedRolePolicies is a helper method to define mock.On call
//   - ctx context.Context
//   - params *iam.ListAttachedRolePoliciesInput
//   - optFns ...func(*iam.Options)
func (_e *MockClient_Expecter) ListAttachedRolePolicies(ctx interface{}, params interface{}, optFns ...interface{}) *MockClient_ListAttachedRolePolicies_Call {
	return &MockClient_ListAttachedRolePolicies_Call{Call: _e.mock.On("ListAttachedRolePolicies",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockClient_ListAttachedRolePolicies_Call) Run(run func(ctx context.Context, params *iam.ListAttachedRolePoliciesInput, optFns ...func(*iam.Options))) *MockClient_ListAttachedRolePolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *iam.ListAttachedRolePoliciesInput
		if args[1] != nil {
			arg1 = args[1].(*iam.ListAttachedRolePoliciesInput)
		}
		var arg2 []func(*iam.Options)
		var variadicArgs []func(*iam.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*iam.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockClient_ListAttachedRolePolicies_Call) Return(listAttachedRolePoliciesOutput *iam.ListAttachedRolePoliciesOutput, err error) *MockClient_ListAttachedRolePolicies_Call {
	_c.Call.Return(listAttachedRolePoliciesOutput, err)
	return _c
}

func (_c *MockClient_ListAttachedRolePolicies_Call) RunAndReturn(run func(ctx context.Context, params *iam.ListAttachedRolePoliciesInput, optFns ...func(*iam.Options)) (*iam.ListAttachedRolePoliciesOutput, error)) *MockClient_ListAttachedRolePolicies_Call {
	_c.Call.Return(run)
	return _c
}

// ListAttachedUserPolicies provides a mock function for the type MockClient
func (_mock *MockClient) ListAttachedUserPolicies(ctx context.Context, params *iam.ListAttachedUserPoliciesInput, optFns ...func(*iam.Options)) (*iam.ListAttachedUserPoliciesOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ListAttachedUserPolicies")
	}

	var r0 *iam.ListAttachedUserPoliciesOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.ListAttachedUserPoliciesInput, ...func(*iam.Options)) (*iam.ListAttachedUserPoliciesOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.ListAttachedUserPoliciesInput, ...func(*iam.Options)) *iam.ListAttachedUserPoliciesOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListAttachedUserPoliciesOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *iam.ListAttachedUserPoliciesInput, ...func(*iam.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_ListAttachedUserPolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListAttachedUserPolicies'
type MockClient_ListAttachedUserPolicies_Call struct {
	*mock.Call
}

// ListAttachedUserPolicies is a helper method to define mock.On call
//   - ctx context.Context
//   - params *iam.ListAttachedUserPoliciesInput
//   - optFns ...func(*iam.Options)
func (_e *MockClient_Expecter) ListAttachedUserPolicies(ctx interface{}, params interface{}, optFns ...interface{}) *MockClient_ListAttachedUserPolicies_Call {
	return &MockClient_ListAttachedUserPolicies_Call{Call: _e.mock.On("ListAttachedUserPolicies",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockClient_ListAttachedUserPolicies_Call) Run(run func(ctx context.Context, params *iam.ListAttachedUserPoliciesInput, optFns ...func(*iam.Options))) *MockClient_ListAttachedUserPolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *iam.ListAttachedUserPoliciesInput
		if args[1] != nil {
			arg1 = args[1].(*iam.ListAttachedUserPoliciesInput)
		}
		var arg2 []func(*iam.Options)
		var variadicArgs []func(*iam.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*iam.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockClient_ListAttachedUserPolicies_Call) Return(listAttachedUserPoliciesOutput *iam.ListAttachedUserPoliciesOutput, err error) *MockClient_ListAttachedUserPolicies_Call {
	_c.Call.Return(listAttachedUserPoliciesOutput, err)
	return _c
}

func (_c *MockClient_ListAttachedUserPolicies_Call) RunAndReturn(run func(ctx context.Context, params *iam.ListAttachedUserPoliciesInput, optFns ...func(*iam.Options)) (*iam.ListAttachedUserPoliciesOutput, error)) *MockClient_ListAttachedUserPolicies_Call {
	_c.Call.Return(run)
	return _c
}

// ListEntitiesForPolicy provides a mock function for the type MockClient
func (_mock *MockClient) ListEntitiesForPolicy(ctx context.Context, params *iam.ListEntitiesForPolicyInput, optFns ...func(*iam.Options)) (*iam.ListEntitiesForPolicyOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ListEntitiesForPolicy")
	}

	var r0 *iam.ListEntitiesForPolicyOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.ListEntitiesForPolicyInput, ...func(*iam.Options)) (*iam.ListEntitiesForPolicyOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.ListEntitiesForPolicyInput, ...func(*iam.Options)) *iam.ListEntitiesForPolicyOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListEntitiesForPolicyOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *iam.ListEntitiesForPolicyInput, ...func(*iam.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_ListEntitiesForPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListEntitiesForPolicy'
type MockClient_ListEntitiesForPolicy_Call struct {
	*mock.Call
}

// ListEntitiesForPolicy is a helper method to define mock.On call
//   - ctx context.Context
//   - params *iam.ListEntitiesForPolicyInput
//   - optFns ...func(*iam.Options)
func (_e *MockClient_Expecter) ListEntitiesForPolicy(ctx interface{}, params interface{}, optFns ...interface{}) *MockClient_ListEntitiesForPolicy_Call {
	return &MockClient_ListEntitiesForPolicy_Call{Call: _e.mock.On("ListEntitiesForPolicy",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockClient_ListEntitiesForPolicy_Call) Run(run func(ctx context.Context, params *iam.ListEntitiesForPolicyInput, optFns ...func(*iam.Options))) *MockClient_ListEntitiesForPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *iam.ListEntitiesForPolicyInput
		if args[1] != nil {
			arg1 = args[1].(*iam.ListEntitiesForPolicyInput)
		}
		var arg2 []func(*iam.Options)
		var variadicArgs []func(*iam.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*iam.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockClient_ListEntitiesForPolicy_Call) Return(listEntitiesForPolicyOutput *iam.ListEntitiesForPolicyOutput, err error) *MockClient_ListEntitiesForPolicy_Call {
	_c.Call.Return(listEntitiesForPolicyOutput, err)
	return _c
}

func (_c *MockClient_ListEntitiesForPolicy_Call) RunAndReturn(run func(ctx context.Context, params *iam.ListEntitiesForPolicyInput, optFns ...func(*iam.Options)) (*iam.ListEntitiesForPolicyOutput, error)) *MockClient_ListEntitiesForPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// ListMFADevices provides a mock function for the type MockClient
func (_mock *MockClient) ListMFADevices(ctx context.Context, params *iam.ListMFADevicesInput, optFns ...func(*iam.Options)) (*iam.ListMFADevicesOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ListMFADevices")
	}

	var r0 *iam.ListMFADevicesOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.ListMFADevicesInput, ...func(*iam.Options)) (*iam.ListMFADevicesOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.ListMFADevicesInput, ...func(*iam.Options)) *iam.ListMFADevicesOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListMFADevicesOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *iam.ListMFADevicesInput, ...func(*iam.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_ListMFADevices_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMFADevices'
type MockClient_ListMFADevices_Call struct {
	*mock.Call
}

// ListMFADevices is a helper method to define mock.On call
//   - ctx context.Context
//   - params *iam.ListMFADevicesInput
//   - optFns ...func(*iam.Options)
func (_e *MockClient_Expecter) ListMFADevices(ctx interface{}, params interface{}, optFns ...interface{}) *MockClient_ListMFADevices_Call {
	return &MockClient_ListMFADevices_Call{Call: _e.mock.On("ListMFADevices",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockClient_ListMFADevices_Call) Run(run func(ctx context.Context, params *iam.ListMFADevicesInput, optFns ...func(*iam.Options))) *MockClient_ListMFADevices_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *iam.ListMFADevicesInput
		if args[1] != nil {
			arg1 = args[1].(*iam.ListMFADevicesInput)
		}
		var arg2 []func(*iam.Options)
		var variadicArgs []func(*iam.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*iam.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockClient_ListMFADevices_Call) Return(listMFADevicesOutput *iam.ListMFADevicesOutput, err error) *MockClient_ListMFADevices_Call {
	_c.Call.Return(listMFADevicesOutput, err)
	return _c
}

func (_c *MockClient_ListMFADevices_Call) RunAndReturn(run func(ctx context.Context, params *iam.ListMFADevicesInput, optFns ...func(*iam.Options)) (*iam.ListMFADevicesOutput, error)) *MockClient_ListMFADevices_Call {
	_c.Call.Return(run)
	return _c
}

// ListPolicies provides a mock function for the type MockClient
func (_mock *MockClient) ListPolicies(ctx context.Context, params *iam.ListPoliciesInput, optFns ...func(*iam.Options)) (*iam.ListPoliciesOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ListPolicies")
	}

	var r0 *iam.ListPoliciesOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.ListPoliciesInput, ...func(*iam.Options)) (*iam.ListPoliciesOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.ListPoliciesInput, ...func(*iam.Options)) *iam.ListPoliciesOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListPoliciesOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *iam.ListPoliciesInput, ...func(*iam.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_ListPolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListPolicies'
type MockClient_ListPolicies_Call struct {
	*mock.Call
}

// ListPolicies is a helper method to define mock.On call
//   - ctx context.Context
//   - params *iam.ListPoliciesInput
//   - optFns ...func(*iam.Options)
func (_e *MockClient_Expecter) ListPolicies(ctx interface{}, params interface{}, optFns ...interface{}) *MockClient_ListPolicies_Call {
	return &MockClient_ListPolicies_Call{Call: _e.mock.On("ListPolicies",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockClient_ListPolicies_Call) Run(run func(ctx context.Context, params *iam.ListPoliciesInput, optFns ...func(*iam.Options))) *MockClient_ListPolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *iam.ListPoliciesInput
		if args[1] != nil {
			arg1 = args[1].(*iam.ListPoliciesInput)
		}
		var arg2 []func(*iam.Options)
		var variadicArgs []func(*iam.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*iam.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockClient_ListPolicies_Call) Return(listPoliciesOutput *iam.ListPoliciesOutput, err error) *MockClient_ListPolicies_Call {
	_c.Call.Return(listPoliciesOutput, err)
	return _c
}

func (_c *MockClient_ListPolicies_Call) RunAndReturn(run func(ctx context.Context, params *iam.ListPoliciesInput, optFns ...func(*iam.Options)) (*iam.ListPoliciesOutput, error)) *MockClient_ListPolicies_Call {
	_c.Call.Return(run)
	return _c
}

// ListRoles provides a mock function for the type MockClient
func (_mock *MockClient) ListRoles(ctx context.Context, params *iam.ListRolesInput, optFns ...func(*iam.Options)) (*iam.ListRolesOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ListRoles")
	}

	var r0 *iam.ListRolesOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.ListRolesInput, ...func(*iam.Options)) (*iam.ListRolesOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.ListRolesInput, ...func(*iam.Options)) *iam.ListRolesOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListRolesOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *iam.ListRolesInput, ...func(*iam.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_ListRoles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListRoles'
type MockClient_ListRoles_Call struct {
	*mock.Call
}

// ListRoles is a helper method to define mock.On call
//   - ctx context.Context
//   - params *iam.ListRolesInput
//   - optFns ...func(*iam.Options)
func (_e *MockClient_Expecter) ListRoles(ctx interface{}, params interface{}, optFns ...interface{}) *MockClient_ListRoles_Call {
	return &MockClient_ListRoles_Call{Call: _e.mock.On("ListRoles",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockClient_ListRoles_Call) Run(run func(ctx context.Context, params *iam.ListRolesInput, optFns ...func(*iam.Options))) *MockClient_ListRoles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *iam.ListRolesInput
		if args[1] != nil {
			arg1 = args[1].(*iam.ListRolesInput)
		}
		var arg2 []func(*iam.Options)
		var variadicArgs []func(*iam.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*iam.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockClient_ListRoles_Call) Return(listRolesOutput *iam.ListRolesOutput, err error) *MockClient_ListRoles_Call {
	_c.Call.Return(listRolesOutput, err)
	return _c
}

func (_c *MockClient_ListRoles_Call) RunAndReturn(run func(ctx context.Context, params *iam.ListRolesInput, optFns ...func(*iam.Options)) (*iam.ListRolesOutput, error)) *MockClient_ListRoles_Call {
	_c.Call.Return(run)
	return _c
}

// ListServerCertificates provides a mock function for the type MockClient
func (_mock *MockClient) ListServerCertificates(ctx context.Context, params *iam.ListServerCertificatesInput, optFns ...func(*iam.Options)) (*iam.ListServerCertificatesOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ListServerCertificates")
	}

	var r0 *iam.ListServerCertificatesOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.ListServerCertificatesInput, ...func(*iam.Options)) (*iam.ListServerCertificatesOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.ListServerCertificatesInput, ...func(*iam.Options)) *iam.ListServerCertificatesOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListServerCertificatesOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *iam.ListServerCertificatesInput, ...func(*iam.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_ListServerCertificates_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListServerCertificates'
type MockClient_ListServerCertificates_Call struct {
	*mock.Call
}

// ListServerCertificates is a helper method to define mock.On call
//   - ctx context.Context
//   - params *iam.ListServerCertificatesInput
//   - optFns ...func(*iam.Options)
func (_e *MockClient_Expecter) ListServerCertificates(ctx interface{}, params interface{}, optFns ...interface{}) *MockClient_ListServerCertificates_Call {
	return &MockClient_ListServerCertificates_Call{Call: _e.mock.On("ListServerCertificates",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockClient_ListServerCertificates_Call) Run(run func(ctx context.Context, params *iam.ListServerCertificatesInput, optFns ...func(*iam.Options))) *MockClient_ListServerCertificates_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *iam.ListServerCertificatesInput
		if args[1] != nil {
			arg1 = args[1].(*iam.ListServerCertificatesInput)
		}
		var arg2 []func(*iam.Options)
		var variadicArgs []func(*iam.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*iam.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockClient_ListServerCertificates_Call) Return(listServerCertificatesOutput *iam.ListServerCertificatesOutput, err error) *MockClient_ListServerCertificates_Call {
	_c.Call.Return(listServerCertificatesOutput, err)
	return _c
}

func (_c *MockClient_ListServerCertificates_Call) RunAndReturn(run func(ctx context.Context, params *iam.ListServerCertificatesInput, optFns ...func(*iam.Options)) (*iam.ListServerCertificatesOutput, error)) *MockClient_ListServerCertificates_Call {
	_c.Call.Return(run)
	return _c
}

// ListUserPolicies provides a mock function for the type MockClient
func (_mock *MockClient) ListUserPolicies(ctx context.Context, params *iam.ListUserPoliciesInput, optFns ...func(*iam.Options)) (*iam.ListUserPoliciesOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ListUserPolicies")
	}

	var r0 *iam.ListUserPoliciesOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.ListUserPoliciesInput, ...func(*iam.Options)) (*iam.ListUserPoliciesOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.ListUserPoliciesInput, ...func(*iam.Options)) *iam.ListUserPoliciesOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListUserPoliciesOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *iam.ListUserPoliciesInput, ...func(*iam.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_ListUserPolicies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListUserPolicies'
type MockClient_ListUserPolicies_Call struct {
	*mock.Call
}

// ListUserPolicies is a helper method to define mock.On call
//   - ctx context.Context
//   - params *iam.ListUserPoliciesInput
//   - optFns ...func(*iam.Options)
func (_e *MockClient_Expecter) ListUserPolicies(ctx interface{}, params interface{}, optFns ...interface{}) *MockClient_ListUserPolicies_Call {
	return &MockClient_ListUserPolicies_Call{Call: _e.mock.On("ListUserPolicies",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockClient_ListUserPolicies_Call) Run(run func(ctx context.Context, params *iam.ListUserPoliciesInput, optFns ...func(*iam.Options))) *MockClient_ListUserPolicies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *iam.ListUserPoliciesInput
		if args[1] != nil {
			arg1 = args[1].(*iam.ListUserPoliciesInput)
		}
		var arg2 []func(*iam.Options)
		var variadicArgs []func(*iam.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*iam.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockClient_ListUserPolicies_Call) Return(listUserPoliciesOutput *iam.ListUserPoliciesOutput, err error) *MockClient_ListUserPolicies_Call {
	_c.Call.Return(listUserPoliciesOutput, err)
	return _c
}

func (_c *MockClient_ListUserPolicies_Call) RunAndReturn(run func(ctx context.Context, params *iam.ListUserPoliciesInput, optFns ...func(*iam.Options)) (*iam.ListUserPoliciesOutput, error)) *MockClient_ListUserPolicies_Call {
	_c.Call.Return(run)
	return _c
}

// ListUsers provides a mock function for the type MockClient
func (_mock *MockClient) ListUsers(ctx context.Context, params *iam.ListUsersInput, optFns ...func(*iam.Options)) (*iam.ListUsersOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ListUsers")
	}

	var r0 *iam.ListUsersOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.ListUsersInput, ...func(*iam.Options)) (*iam.ListUsersOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.ListUsersInput, ...func(*iam.Options)) *iam.ListUsersOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListUsersOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *iam.ListUsersInput, ...func(*iam.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_ListUsers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListUsers'
type MockClient_ListUsers_Call struct {
	*mock.Call
}

// ListUsers is a helper method to define mock.On call
//   - ctx context.Context
//   - params *iam.ListUsersInput
//   - optFns ...func(*iam.Options)
func (_e *MockClient_Expecter) ListUsers(ctx interface{}, params interface{}, optFns ...interface{}) *MockClient_ListUsers_Call {
	return &MockClient_ListUsers_Call{Call: _e.mock.On("ListUsers",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockClient_ListUsers_Call) Run(run func(ctx context.Context, params *iam.ListUsersInput, optFns ...func(*iam.Options))) *MockClient_ListUsers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *iam.ListUsersInput
		if args[1] != nil {
			arg1 = args[1].(*iam.ListUsersInput)
		}
		var arg2 []func(*iam.Options)
		var variadicArgs []func(*iam.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*iam.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockClient_ListUsers_Call) Return(listUsersOutput *iam.ListUsersOutput, err error) *MockClient_ListUsers_Call {
	_c.Call.Return(listUsersOutput, err)
	return _c
}

func (_c *MockClient_ListUsers_Call) RunAndReturn(run func(ctx context.Context, params *iam.ListUsersInput, optFns ...func(*iam.Options)) (*iam.ListUsersOutput, error)) *MockClient_ListUsers_Call {
	_c.Call.Return(run)
	return _c
}

// ListVirtualMFADevices provides a mock function for the type MockClient
func (_mock *MockClient) ListVirtualMFADevices(ctx context.Context, params *iam.ListVirtualMFADevicesInput, optFns ...func(*iam.Options)) (*iam.ListVirtualMFADevicesOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ListVirtualMFADevices")
	}

	var r0 *iam.ListVirtualMFADevicesOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.ListVirtualMFADevicesInput, ...func(*iam.Options)) (*iam.ListVirtualMFADevicesOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *iam.ListVirtualMFADevicesInput, ...func(*iam.Options)) *iam.ListVirtualMFADevicesOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.ListVirtualMFADevicesOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *iam.ListVirtualMFADevicesInput, ...func(*iam.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockClient_ListVirtualMFADevices_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListVirtualMFADevices'
type MockClient_ListVirtualMFADevices_Call struct {
	*mock.Call
}

// ListVirtualMFADevices is a helper method to define mock.On call
//   - ctx context.Context
//   - params *iam.ListVirtualMFADevicesInput
//   - optFns ...func(*iam.Options)
func (_e *MockClient_Expecter) ListVirtualMFADevices(ctx interface{}, params interface{}, optFns ...interface{}) *MockClient_ListVirtualMFADevices_Call {
	return &MockClient_ListVirtualMFADevices_Call{Call: _e.mock.On("ListVirtualMFADevices",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockClient_ListVirtualMFADevices_Call) Run(run func(ctx context.Context, params *iam.ListVirtualMFADevicesInput, optFns ...func(*iam.Options))) *MockClient_ListVirtualMFADevices_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *iam.ListVirtualMFADevicesInput
		if args[1] != nil {
			arg1 = args[1].(*iam.ListVirtualMFADevicesInput)
		}
		var arg2 []func(*iam.Options)
		var variadicArgs []func(*iam.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*iam.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockClient_ListVirtualMFADevices_Call) Return(listVirtualMFADevicesOutput *iam.ListVirtualMFADevicesOutput, err error) *MockClient_ListVirtualMFADevices_Call {
	_c.Call.Return(listVirtualMFADevicesOutput, err)
	return _c
}

func (_c *MockClient_ListVirtualMFADevices_Call) RunAndReturn(run func(ctx context.Context, params *iam.ListVirtualMFADevicesInput, optFns ...func(*iam.Options)) (*iam.ListVirtualMFADevicesOutput, error)) *MockClient_ListVirtualMFADevices_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockAccessAnalyzerClient creates a new instance of MockAccessAnalyzerClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockAccessAnalyzerClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockAccessAnalyzerClient {
	mock := &MockAccessAnalyzerClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockAccessAnalyzerClient is an autogenerated mock type for the AccessAnalyzerClient type
type MockAccessAnalyzerClient struct {
	mock.Mock
}

type MockAccessAnalyzerClient_Expecter struct {
	mock *mock.Mock
}

func (_m *MockAccessAnalyzerClient) EXPECT() *MockAccessAnalyzerClient_Expecter {
	return &MockAccessAnalyzerClient_Expecter{mock: &_m.Mock}
}

// ListAnalyzers provides a mock function for the type MockAccessAnalyzerClient
func (_mock *MockAccessAnalyzerClient) ListAnalyzers(ctx context.Context, params *accessanalyzer.ListAnalyzersInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.ListAnalyzersOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ListAnalyzers")
	}

	var r0 *accessanalyzer.ListAnalyzersOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *accessanalyzer.ListAnalyzersInput, ...func(*accessanalyzer.Options)) (*accessanalyzer.ListAnalyzersOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *accessanalyzer.ListAnalyzersInput, ...func(*accessanalyzer.Options)) *accessanalyzer.ListAnalyzersOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accessanalyzer.ListAnalyzersOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *accessanalyzer.ListAnalyzersInput, ...func(*accessanalyzer.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAccessAnalyzerClient_ListAnalyzers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListAnalyzers'
type MockAccessAnalyzerClient_ListAnalyzers_Call struct {
	*mock.Call
}

// ListAnalyzers is a helper method to define mock.On call
//   - ctx context.Context
//   - params *accessanalyzer.ListAnalyzersInput
//   - optFns ...func(*accessanalyzer.Options)
func (_e *MockAccessAnalyzerClient_Expecter) ListAnalyzers(ctx interface{}, params interface{}, optFns ...interface{}) *MockAccessAnalyzerClient_ListAnalyzers_Call {
	return &MockAccessAnalyzerClient_ListAnalyzers_Call{Call: _e.mock.On("ListAnalyzers",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockAccessAnalyzerClient_ListAnalyzers_Call) Run(run func(ctx context.Context, params *accessanalyzer.ListAnalyzersInput, optFns ...func(*accessanalyzer.Options))) *MockAccessAnalyzerClient_ListAnalyzers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *accessanalyzer.ListAnalyzersInput
		if args[1] != nil {
			arg1 = args[1].(*accessanalyzer.ListAnalyzersInput)
		}
		var arg2 []func(*accessanalyzer.Options)
		var variadicArgs []func(*accessanalyzer.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*accessanalyzer.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockAccessAnalyzerClient_ListAnalyzers_Call) Return(listAnalyzersOutput *accessanalyzer.ListAnalyzersOutput, err error) *MockAccessAnalyzerClient_ListAnalyzers_Call {
	_c.Call.Return(listAnalyzersOutput, err)
	return _c
}

func (_c *MockAccessAnalyzerClient_ListAnalyzers_Call) RunAndReturn(run func(ctx context.Context, params *accessanalyzer.ListAnalyzersInput, optFns ...func(*accessanalyzer.Options)) (*accessanalyzer.ListAnalyzersOutput, error)) *MockAccessAnalyzerClient_ListAnalyzers_Call {
	_c.Call.Return(run)
	return _c
}
