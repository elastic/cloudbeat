// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package vulnerability

import (
	"context"
	"encoding/json"
	"errors"
	"os"
	"sync"
	"testing"
	"time"

	"github.com/aquasecurity/trivy/pkg/flag"
	trivytypes "github.com/aquasecurity/trivy/pkg/types"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/ec2/types"
	"github.com/elastic/beats/v7/libbeat/beat"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
	"go.uber.org/goleak"

	"github.com/elastic/cloudbeat/internal/config"
	"github.com/elastic/cloudbeat/internal/dataprovider"
	"github.com/elastic/cloudbeat/internal/resources/providers/awslib/ec2"
	"github.com/elastic/cloudbeat/internal/resources/utils/testhelper"
)

type runnerMock struct {
	report trivytypes.Report
	err    error
}

func (s runnerMock) ScanVM(_ context.Context, opts flag.Options) (trivytypes.Report, error) {
	writer, err := os.OpenFile(opts.ReportOptions.Output, os.O_APPEND|os.O_WRONLY, 0o644)
	if err != nil {
		return trivytypes.Report{}, err
	}
	defer func() {
		_ = writer.Close() // ignore error
	}()
	b, err := json.Marshal(s.report)
	if err != nil {
		return trivytypes.Report{}, err
	}
	_, err = writer.Write(b)
	if err != nil {
		return trivytypes.Report{}, err
	}
	return s.report, s.err
}

func (s runnerMock) Filter(context.Context, flag.Options, trivytypes.Report) (trivytypes.Report, error) {
	return s.report, s.err
}

func (s runnerMock) Report(context.Context, flag.Options, trivytypes.Report) error {
	return s.err
}

func (s runnerMock) Close(context.Context) error {
	return s.err
}

func TestNewVulnerabilityWorker(t *testing.T) {
	testhelper.SkipLong(t)

	c := &config.Config{}
	log := testhelper.NewLogger(t)
	bdp := &dataprovider.MockCommonDataProvider{}
	cdp := &dataprovider.MockElasticCommonDataProvider{}

	worker, err := NewVulnerabilityWorker(context.Background(), log, c, bdp, cdp)

	defer goleak.VerifyNone(t, goleak.IgnoreCurrent(), goleak.Cleanup(func(_ int) {
		require.NoError(t, worker.runner.GetRunner().Close(context.Background()))
	}))

	require.NoError(t, err)
	assert.NotNil(t, worker.log)
	assert.NotNil(t, worker.fetcher)
	assert.NotNil(t, worker.replicator)
	assert.NotNil(t, worker.verifier)
	assert.NotNil(t, worker.evaluator)
	assert.NotNil(t, worker.eventsCreator)
	assert.NotNil(t, worker.runner)

	ch := worker.GetChan()
	assert.NotNil(t, ch)
}

func TestVulnerabilityWorker_Run(t *testing.T) {
	testhelper.SkipLong(t)
	ctx := context.Background()
	log := testhelper.NewLogger(t)
	defer goleak.VerifyNone(t, goleak.IgnoreCurrent())

	mockCommonDataProvider := dataprovider.NewMockCommonDataProvider(t)
	mockCommonDataProvider.EXPECT().EnrichEvent(mock.Anything, mock.Anything).Return(nil)

	mockEnricher := NewMockEnricher(t)
	mockEnricher.EXPECT().EnrichEvent(mock.Anything).Return(nil)

	mockSnapshotCreatorDeleterProvider := newMockSnapshotCreatorDeleter(t)
	mockSnapshotCreatorDeleterProvider.EXPECT().CreateSnapshots(mock.Anything, mock.Anything).Return([]ec2.EBSSnapshot{
		{
			Instance: ec2.Ec2Instance{
				Instance: types.Instance{InstanceId: aws.String("instance-1")},
			},
			SnapshotId: "snapshot-1",
			Region:     "region",
		},
	}, nil).Times(1)
	mockSnapshotCreatorDeleterProvider.EXPECT().DeleteSnapshot(mock.Anything, mock.Anything).Return(nil).Times(1)

	fetcherProvider := newMockInstancesProvider(t)
	fetcherProvider.EXPECT().DescribeInstances(mock.Anything).Return([]*ec2.Ec2Instance{
		{
			Instance: types.Instance{InstanceId: aws.String("instance-1")},
			Region:   "region",
		},
	}, nil).Times(1)
	fetcherProvider.EXPECT().DescribeVolumes(mock.Anything, mock.Anything).Return(nil, errors.New("error")).Times(1)

	verifierProvider := newMockSnapshotDescriber(t)
	verifierProvider.EXPECT().DescribeSnapshots(mock.Anything, mock.Anything).Return([]ec2.EBSSnapshot{
		{
			Instance: ec2.Ec2Instance{
				Instance: types.Instance{InstanceId: aws.String("instance-1")},
			},
			SnapshotId: "snapshot-1",
			State:      types.SnapshotStateCompleted,
			Region:     "region",
		},
	}, nil).Times(1)

	eventsCreator := EventsCreator{
		log:                log,
		cloudDataProvider:  mockCommonDataProvider,
		commonDataProvider: mockEnricher,
		ch:                 make(chan []beat.Event),
	}

	// Not used runner, just to increase coverage
	runner, err := NewVulnerabilityRunner(ctx, log)
	require.NoError(t, err)
	err = runner.GetRunner().Close(ctx)
	require.NoError(t, err)

	report := trivytypes.Report{
		Results: []trivytypes.Result{
			{
				Vulnerabilities: []trivytypes.DetectedVulnerability{
					{
						VulnerabilityID:  "CVE-2604-1992",
						PkgName:          "test",
						InstalledVersion: "1.0.0",
						FixedVersion:     "1.0.1",
					},
				},
			},
		},
	}
	manager := NewSnapshotManager(log, mockSnapshotCreatorDeleterProvider)
	scanner, err := NewVulnerabilityScanner(
		log,
		&runnerMock{
			report: report,
			err:    nil,
		},
		manager,
		&config.Config{},
		time.Now(),
	)
	require.NoError(t, err)

	replicator := NewVulnerabilityReplicator(log, manager)
	fetcher := NewVulnerabilityFetcher(log, fetcherProvider)
	verifier := NewVulnerabilityVerifier(log, verifierProvider)

	worker := VulnerabilityWorker{
		log:           log,
		fetcher:       fetcher,
		replicator:    replicator,
		verifier:      verifier,
		evaluator:     scanner,
		runner:        runner,
		eventsCreator: eventsCreator,
		manager:       manager,
	}

	ch := worker.GetChan()
	require.NotNil(t, ch)

	var wg sync.WaitGroup
	wg.Add(1)
	defer wg.Wait()
	go func() {
		defer wg.Done()
		worker.Run(ctx)
	}()

	expectedEvents := report.Results[0].Vulnerabilities
	receivedEvents := make([]beat.Event, 0, len(expectedEvents))
	for in := range ch {
		receivedEvents = append(receivedEvents, in...)
	}

	_, ok := <-ch
	assert.False(t, ok)

	assert.Equal(t, len(expectedEvents), len(receivedEvents))

	for i := range receivedEvents {
		ex := expectedEvents[i]
		got := receivedEvents[i]

		gotVulnerability := got.Fields["vulnerability"]
		assert.NotEmpty(t, gotVulnerability)
		gotPackage := got.Fields["package"]
		assert.NotEmpty(t, gotPackage)

		assert.Equal(t, ex.PkgName, gotPackage.(Package).Name)
		assert.Equal(t, ex.FixedVersion, gotPackage.(Package).FixedVersion)
		assert.Equal(t, ex.InstalledVersion, gotPackage.(Package).Version)
		assert.Equal(t, ex.VulnerabilityID, gotVulnerability.(Vulnerability).ID)
	}
}
