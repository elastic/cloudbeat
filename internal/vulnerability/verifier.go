// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package vulnerability

import (
	"context"
	"time"

	"github.com/aws/aws-sdk-go-v2/service/ec2/types"

	"github.com/elastic/cloudbeat/internal/resources/providers/awslib/ec2"
	"github.com/elastic/cloudbeat/internal/resources/utils/clog"
)

const (
	creationTimeout     = 30 * time.Minute
	statusCheckInterval = 15 * time.Second
)

type VulnerabilityVerifier struct {
	log      *clog.Logger
	provider snapshotProvider
	ch       chan ec2.EBSSnapshot
	interval time.Duration
	timeout  time.Duration
}

type snapshotProvider interface {
	DescribeSnapshots(ctx context.Context, snap ec2.EBSSnapshot) ([]ec2.EBSSnapshot, error)
}

func NewVulnerabilityVerifier(log *clog.Logger, provider snapshotProvider) VulnerabilityVerifier {
	log.Debug("VulnerabilityVerifier: New")
	ch := make(chan ec2.EBSSnapshot)
	return VulnerabilityVerifier{
		log:      log,
		ch:       ch,
		provider: provider,
		interval: statusCheckInterval,
		timeout:  creationTimeout,
	}
}

// TODO: Maybe verify more than one snapshot
func (f VulnerabilityVerifier) VerifySnapshot(ctx context.Context, snapCh chan ec2.EBSSnapshot) {
	f.log.Info("Starting VulnerabilityVerifier.VerifySnapshot")
	defer close(f.ch)
	for {
		select {
		case <-ctx.Done():
			f.log.Info("VulnerabilityVerifier.VerifySnapshot context canceled")
			return
		case data, ok := <-snapCh:
			if !ok {
				f.log.Info("VulnerabilityVerifier.VerifySnapshot channel is closed")
				return
			}

			now := time.Now()
			f.verify(ctx, data)
			f.log.Debugf(
				"VulnerabilityVerifier.VerifySnapshot took %s to verify snapshot %s, volume size: %d, isEncrypted: %t",
				time.Since(now),
				data.SnapshotId,
				data.VolumeSize,
				data.IsEncrypted,
			)
		}
	}
}

func (f VulnerabilityVerifier) verify(ctx context.Context, snap ec2.EBSSnapshot) {
	f.log.Info("Starting VulnerabilityVerifier.verify")
	timer := time.After(f.timeout)
	for {
		select {
		case <-timer:
			f.log.Warnf(
				"VulnerabilityVerifier.verify timed out waiting for snapshot %s, Encrypted: %t",
				snap.SnapshotId,
				snap.IsEncrypted,
			)
			return
		case <-ctx.Done():
			f.log.Info("VulnerabilityVerifier.verify context canceled")
			return
		case <-time.After(f.interval):
			sp, err := f.provider.DescribeSnapshots(ctx, snap)
			if err != nil {
				f.log.Errorf("VulnerabilityVerifier.verify.DescribeSnapshots failed: %v", err)
				continue
			}
			// TODO: Add a layer of "smart" cache to avoid checking and sending the same snapshot
			// and not to wait on all snapshots to be completed, sending them periodically
			allCompleted := true
			for _, i := range sp {
				if i.State != types.SnapshotStateCompleted {
					f.log.Infof("VulnerabilityVerifier.verify.VerifySnapshot snapshot not completed yet - %s, instanceId: %s", snap.SnapshotId, *snap.Instance.InstanceId)
					allCompleted = false
					break
				}
			}
			if allCompleted {
				for _, i := range sp {
					select {
					case <-ctx.Done():
						f.log.Info("VulnerabilityVerifier.verify context canceled")
						return
					case f.ch <- i:
					}
				}
				f.log.Infof("VulnerabilityVerifier.verify.VerifySnapshot snapshot completed %s, instanceId: %s", snap.SnapshotId, *snap.Instance.InstanceId)
				return
			}
		}
	}
}

func (f VulnerabilityVerifier) GetChan() chan ec2.EBSSnapshot {
	return f.ch
}
