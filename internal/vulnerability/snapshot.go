// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package vulnerability

import (
	"context"
	"sync"
	"time"

	"github.com/elastic/cloudbeat/internal/infra/clog"
	"github.com/elastic/cloudbeat/internal/resources/providers/awslib/ec2"
)

type snapshotCreatorDeleter interface {
	CreateSnapshots(ctx context.Context, ins *ec2.Ec2Instance) ([]ec2.EBSSnapshot, error)
	DeleteSnapshot(ctx context.Context, snapshot ec2.EBSSnapshot) error
}

type SnapshotManager struct {
	lock      sync.Mutex
	snapshots map[string]ec2.EBSSnapshot

	wg       sync.WaitGroup
	provider snapshotCreatorDeleter
	logger   *clog.Logger
}

func NewSnapshotManager(logger *clog.Logger, provider snapshotCreatorDeleter) *SnapshotManager {
	return &SnapshotManager{
		lock:      sync.Mutex{},
		snapshots: make(map[string]ec2.EBSSnapshot),
		wg:        sync.WaitGroup{},
		provider:  provider,
		logger:    logger,
	}
}

func (s *SnapshotManager) CreateSnapshots(ctx context.Context, ins *ec2.Ec2Instance) ([]ec2.EBSSnapshot, error) {
	snaps, err := s.provider.CreateSnapshots(ctx, ins)
	if err != nil {
		return nil, err
	}
	s.lock.Lock()
	defer s.lock.Unlock()

	for _, snap := range snaps {
		s.snapshots[snap.SnapshotId] = snap
	}
	return snaps, err
}

func (s *SnapshotManager) DeleteSnapshot(ctx context.Context, snapshot ec2.EBSSnapshot) {
	s.wg.Add(1)
	go runWithGrace(ctx, shutdownGracePeriod, func(ctx context.Context) {
		defer s.wg.Done()
		s.delete(ctx, snapshot)
	})

	s.lock.Lock()
	defer s.lock.Unlock()
	delete(s.snapshots, snapshot.SnapshotId)
}

func (s *SnapshotManager) Cleanup(ctx context.Context) {
	s.lock.Lock()
	defer s.lock.Unlock()
	defer s.wg.Wait() // wait for all goroutines started either by DeleteSnapshot to finish
	runWithGrace(ctx, shutdownGracePeriod, func(ctx context.Context) {
		for _, snap := range s.snapshots {
			s.delete(ctx, snap)
		}
	})
}

func (s *SnapshotManager) delete(ctx context.Context, snapshot ec2.EBSSnapshot) {
	s.logger.Infof("VulnerabilityScanner.manager.DeleteSnapshot %s", snapshot.SnapshotId)
	err := s.provider.DeleteSnapshot(ctx, snapshot)
	if err != nil {
		s.logger.Errorf("VulnerabilityScanner.manager.DeleteSnapshot %s error: %s", snapshot.SnapshotId, err)
	}
}

// runWithGrace runs the given function with the given context but allowing an extra given grace period after the
// context is cancelled.
func runWithGrace(ctx context.Context, grace time.Duration, f func(ctx context.Context)) {
	// WithoutCancel: disassociate the cancellation of ctx from the cancellation of newCtx
	// WithCancel: add a cancellation mechanism to the new context
	newCtx, cancel := context.WithCancel(context.WithoutCancel(ctx))
	defer cancel()                          // in all cases, call cancel after the callback is finished
	stop := context.AfterFunc(ctx, func() { // called after original context is cancelled
		time.AfterFunc(grace, cancel) // wait for grace period and then cancel newCtx
	})
	defer stop() // if the callback finishes in time, stop the AfterFunc
	f(newCtx)    // finally, call the actual callback!
}
