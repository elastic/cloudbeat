// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package flavors

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/elastic/cloudbeat/config"
	"github.com/elastic/cloudbeat/dataprovider"
	_ "github.com/elastic/cloudbeat/processor" // Add vulnerability default processors.
	"github.com/elastic/cloudbeat/transformer"
	vuln "github.com/elastic/cloudbeat/vulnerability"

	"github.com/elastic/beats/v7/libbeat/beat"
	"github.com/elastic/beats/v7/libbeat/processors"
	agentconfig "github.com/elastic/elastic-agent-libs/config"
	"github.com/elastic/elastic-agent-libs/logp"
)

// vulnerability configuration.
type vulnerability struct {
	flavorBase
}

// NewVulnerability creates an instance of vulnerability.
func NewVulnerability(_ *beat.Beat, cfg *agentconfig.C) (*vulnerability, error) {
	log := logp.NewLogger("vulnerability")

	ctx, cancel := context.WithCancel(context.Background())

	c, err := config.New(cfg)
	if err != nil {
		cancel()
		return nil, fmt.Errorf("error reading config file: %w", err)
	}

	log.Info("Config initiated with cycle period of ", c.Period)

	// namespace will be passed as param from fleet on https://github.com/elastic/security-team/issues/2383 and it's user configurable
	resultsIndex := config.Datastream("", config.ResultsDatastreamIndexPrefix)

	commonDataProvider := dataprovider.NewCommonDataProvider(log, c)
	commonData, err := commonDataProvider.FetchCommonData(ctx)
	if err != nil {
		cancel()
		return nil, err
	}

	t := transformer.NewTransformer(log, commonData, resultsIndex)

	base := flavorBase{
		ctx:         ctx,
		cancel:      cancel,
		config:      c,
		transformer: t,
		log:         log,
	}

	bt := &vulnerability{
		flavorBase: base,
	}

	return bt, nil
}

// Run starts vulnerability.
func (bt *vulnerability) Run(b *beat.Beat) error {
	bt.log.Info("vulnerability is running! Hit CTRL-C to stop it.")

	procs, err := bt.configureProcessors(bt.config.Processors)
	if err != nil {
		return err
	}
	bt.log.Debugf("vulnerability configured %d processors", len(bt.config.Processors))

	// Connect publisher (with beat's processors)
	if bt.client, err = b.Publisher.ConnectWith(beat.ClientConfig{
		Processing: beat.ProcessingConfig{
			Processor: procs,
		},
	}); err != nil {
		return err
	}

	// TODO: Should trigger first cycle without waiting for ticker.
	workerTicker := time.NewTicker(bt.config.Period)
	for {
		select {
		case <-bt.ctx.Done():
			bt.log.Warn("vulnerability.Run context is done")
			return nil

		case <-workerTicker.C:
			worker, err := vuln.NewVulnerabilityWorker(bt.log, bt.config)
			if err != nil {
				bt.cancel()
				return err
			}
			wg := sync.WaitGroup{}
			wg.Add(1)
			go func() {
				defer wg.Done()
				bt.handleEvents(worker.GetChan())
			}()
			worker.Run(bt.ctx)
			wg.Wait()
		}
	}
}

func (bt *vulnerability) handleEvents(ch chan beat.Event) {
	var eventsToSend []beat.Event
	flushTicker := time.NewTicker(flushInterval)
	for {
		select {
		case <-bt.ctx.Done():
			bt.log.Warn("vulnerability.handleEvents context is done")
			return

		// Flush events to ES after a pre-defined interval, meant to clean residuals after a cycle is finished.
		case <-flushTicker.C:
			if len(eventsToSend) == 0 {
				continue
			}

			bt.log.Infof("vulnerability.handleEvents Publishing %d vulnerability events to elasticsearch, time interval reached", len(eventsToSend))
			// bt.client.PublishAll(eventsToSend)
			eventsToSend = nil

		// Flush events to ES when reaching a certain threshold
		case event, ok := <-ch:
			if !ok {
				bt.log.Warn("vulnerability.handleEvents worker channel is closed")
				if len(eventsToSend) > 0 {
					bt.log.Infof("Publishing %d cloudbeat events to elasticsearch, worker channel is closed", len(eventsToSend))
					// bt.client.PublishAll(eventsToSend)
					eventsToSend = nil
				}
				return
			}

			eventsToSend = append(eventsToSend, event)
			if len(eventsToSend) < eventsThreshold {
				continue
			}

			bt.log.Infof("Publishing %d cloudbeat events to elasticsearch, buffer threshold reached", len(eventsToSend))
			// bt.client.PublishAll(eventsToSend)
			eventsToSend = nil
		}
	}
}

// Stop stops vulnerability.
func (bt *vulnerability) Stop() {
	bt.cancel()
}

// configureProcessors configure processors to be used by the beat
func (bt *vulnerability) configureProcessors(processorsList processors.PluginConfig) (procs *processors.Processors, err error) {
	return processors.New(processorsList)
}
