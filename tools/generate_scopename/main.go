// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package main

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
)

const format = `
// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
// Code generated by go generate; DO NOT EDIT.
package %s

const scopeName = "%s"
`

func main() {
	gofile := os.Getenv("GOFILE")
	if gofile == "" {
		log.Fatal("GOFILE environment variable not set")
	}

	pkgName := os.Getenv("GOPACKAGE")
	if pkgName == "" {
		log.Fatal("GOPACKAGE environment variable not set")
	}

	pkgPath, err := getPackageImportPath(gofile)
	if err != nil {
		log.Fatalf("Failed to get package import path for %s: %v", gofile, err)
	}

	content := fmt.Sprintf(format, pkgName, pkgPath)
	content = strings.TrimSpace(content) + "\n"

	if err := os.WriteFile(filepath.Join(filepath.Dir(gofile), "scope.go"), []byte(content), 0644); err != nil {
		log.Fatalf("Failed to write file: %v", err)
	}
}

func getPackageImportPath(filename string) (string, error) {
	absPath, err := filepath.Abs(filename)
	if err != nil {
		return "", err
	}

	dir := filepath.Dir(absPath)
	modFile, err := findGoModFile(dir)
	if err != nil {
		return "", fmt.Errorf("could not find go.mod file for %s: %w", filename, err)
	}

	modContent, err := os.ReadFile(modFile)
	if err != nil {
		return "", fmt.Errorf("could not read go.mod file %s: %w", modFile, err)
	}

	modPath := getModulePath(modContent)
	if modPath == "" {
		return "", fmt.Errorf("could not find module path in %s", modFile)
	}

	relPath, err := filepath.Rel(filepath.Dir(modFile), dir)
	if err != nil {
		return "", err
	}

	return filepath.ToSlash(filepath.Join(modPath, relPath)), nil
}

func findGoModFile(dir string) (string, error) {
	for {
		modFile := filepath.Join(dir, "go.mod")
		if _, err := os.Stat(modFile); err == nil {
			return modFile, nil
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			return "", os.ErrNotExist
		}
		dir = parent
	}
}

func getModulePath(modContent []byte) string {
	lines := strings.Split(string(modContent), "\n")
	for _, line := range lines {
		if strings.HasPrefix(line, "module") {
			return strings.TrimSpace(strings.TrimPrefix(line, "module"))
		}
	}
	return ""
}
