// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package main

import (
	"errors"
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"

	"golang.org/x/mod/modfile"
)

const format = `
// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
// Code generated by go generate; DO NOT EDIT.
package %s

const scopeName = "%s"
`

const usage = `This tool is intended to be used with 'go generate'.
It creates a 'scope_generated.go' file in the package where it is executed.
This file includes a 'scopeName' constant, which holds the Go package path as its value.
The tool depends on the 'GOFILE' and 'GOPACKAGE' environment variables being set.
`

func main() {
	if displayUsage() {
		fmt.Print(usage)
		os.Exit(0)
	}

	gofile := os.Getenv("GOFILE")
	if gofile == "" {
		log.Fatal("GOFILE environment variable not set")
	}

	pkgName := os.Getenv("GOPACKAGE")
	if pkgName == "" {
		log.Fatal("GOPACKAGE environment variable not set")
	}

	pkgPath, err := getPackageImportPath(gofile)
	if err != nil {
		log.Fatalf("Failed to get package import path for %s: %v", gofile, err)
	}

	content := fmt.Sprintf(format, pkgName, pkgPath)
	content = strings.TrimSpace(content) + "\n"

	if err := os.WriteFile(filepath.Join(filepath.Dir(gofile), "scope_generated.go"), []byte(content), 0644); err != nil {
		log.Fatalf("Failed to write file: %v", err)
	}
}

func displayUsage() bool {
	help := flag.Bool("help", false, "show help message")
	h := flag.Bool("h", false, "show help message")
	flag.Parse()
	return *help || *h
}

func getPackageImportPath(filename string) (string, error) {
	absPath, err := filepath.Abs(filename)
	if err != nil {
		return "", err
	}

	dir := filepath.Dir(absPath)
	modFile, err := findGoModFile(dir)
	if err != nil {
		return "", fmt.Errorf("could not find go.mod file for %s: %w", filename, err)
	}

	modContent, err := os.ReadFile(modFile)
	if err != nil {
		return "", fmt.Errorf("could not read go.mod file %s: %w", modFile, err)
	}

	modPath, err := getModulePath(modContent)
	if err != nil {
		return "", fmt.Errorf("could not find module path in %s: %w", modFile, err)
	}

	relPath, err := filepath.Rel(filepath.Dir(modFile), dir)
	if err != nil {
		return "", err
	}

	return filepath.ToSlash(filepath.Join(modPath, relPath)), nil
}

func findGoModFile(dir string) (string, error) {
	for {
		modFile := filepath.Join(dir, "go.mod")
		if _, err := os.Stat(modFile); err == nil {
			return modFile, nil
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			return "", os.ErrNotExist
		}
		dir = parent
	}
}

func getModulePath(modContent []byte) (string, error) {
	f, err := modfile.Parse("go.mod", modContent, nil)
	if err != nil {
		return "", err
	}
	if f.Module == nil {
		return "", errors.New("cannot find module path")
	}
	return f.Module.Mod.Path, nil
}
